<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=8" />
    <meta http-equiv="Content-Script-Type" content="text/javascript" />
    <title>Sproutcore Runtime</title>
  <script type="text/javascript">
/* >>>>>>>>>> BEGIN source/core.js */
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

; if ((typeof SC !== 'undefined') && SC && SC.scriptDidLoad) SC.scriptDidLoad('sproutcore/bootstrap');
/* >>>>>>>>>> BEGIN source/system/browser.js */
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

var SC = SC || { BUNDLE_INFO: {}, LAZY_INSTANTIATION: {} };

SC.browser = (function() {
  var userAgent = navigator.userAgent.toLowerCase();
  var version = (userAgent.match( /.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [])[1] ;

  var browser = {
    version: version,
    safari: (/webkit/).test( userAgent ) ? version : 0,
    opera: (/opera/).test( userAgent ) ? version : 0,
    msie: (/msie/).test( userAgent ) && !(/opera/).test( userAgent ) ? version : 0,
    mozilla: (/mozilla/).test( userAgent ) && !(/(compatible|webkit)/).test( userAgent ) ? version : 0,
    mobileSafari: (/apple.*mobile.*safari/).test(userAgent) ? version : 0,
    windows: !!(/(windows)/).test(userAgent),
    mac: !!((/(macintosh)/).test(userAgent) || (/(mac os x)/).test(userAgent)),
    language: (navigator.language || navigator.browserLanguage).split('-', 1)[0]
  };
  
    browser.current = browser.msie ? 'msie' : browser.mozilla ? 'mozilla' : browser.safari ? 'safari' : browser.opera ? 'opera' : 'unknown' ;
  return browser ;
})();
; if ((typeof SC !== 'undefined') && SC && SC.scriptDidLoad) SC.scriptDidLoad('sproutcore/bootstrap');
/* >>>>>>>>>> BEGIN source/system/loader.js */
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

SC.bundleDidLoad = function(bundle) {
  var info = this.BUNDLE_INFO[bundle] ;
  if (!info) info = this.BUNDLE_INFO[bundle] = {} ;
  info.loaded = true ;
};

SC.bundleIsLoaded = function(bundle) {
  var info = this.BUNDLE_INFO[bundle] ;
  return info ? !!info.loaded : false ;
};

SC.loadBundle = function() { throw "SC.loadBundle(): SproutCore is not loaded."; };

SC.setupBodyClassNames = function() {
  var el = document.body ;
  if (!el) return ;
  var browser, platform, shadows, borderRad, classNames, style;
  browser = SC.browser.current ;
  platform = SC.browser.windows ? 'windows' : SC.browser.mac ? 'mac' : 'other-platform' ;
  style = document.documentElement.style;
  shadows = (style.MozBoxShadow !== undefined) || 
                (style.webkitBoxShadow !== undefined) ||
                (style.oBoxShadow !== undefined) ||
                (style.boxShadow !== undefined);
  
  borderRad = (style.MozBorderRadius !== undefined) || 
              (style.webkitBorderRadius !== undefined) ||
              (style.oBorderRadius !== undefined) ||
              (style.borderRadius !== undefined);
  
  classNames = el.className ? el.className.split(' ') : [] ;
  if(shadows) classNames.push('box-shadow');
  if(borderRad) classNames.push('border-rad');
  classNames.push(browser) ;
  classNames.push(platform) ;
  if (SC.browser.mobileSafari) classNames.push('mobile-safari') ;
  el.className = classNames.join(' ') ;
} ;
; if ((typeof SC !== 'undefined') && SC && SC.scriptDidLoad) SC.scriptDidLoad('sproutcore/bootstrap');
/* >>>>>>>>>> BEGIN bundle_loaded.js */
; if ((typeof SC !== 'undefined') && SC && SC.bundleDidLoad) SC.bundleDidLoad('sproutcore/bootstrap');

</script>

     <link href="/static/sproutcore/testing/en/current/stylesheet.css?1256536762" rel="stylesheet" type="text/css" />
   
    
  </head>
    
  <body class="sc-theme focus" style="overflow:hidden;" >  
<script type="text/javascript">
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

// sc_resource('setup_body_class_names'); // publish into inline format

if (SC.setupBodyClassNames) SC.setupBodyClassNames() ;
; if ((typeof SC !== 'undefined') && SC && SC.scriptDidLoad) SC.scriptDidLoad('sproutcore/bootstrap');
</script>


  <script type="text/javascript" src="/static/sproutcore/debug/en/current/source/core.js?1256536761"></script>
  <script type="text/javascript" src="/static/sproutcore/debug/en/current/bundle_loaded.js?0"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/core.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/utils.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/extras.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/jquery.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/qunit.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/system/dump.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/system/equiv.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/system/plan.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/system/runner.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/source/system/suite.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/testing/en/current/bundle_loaded.js?0"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/license.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/core.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/base.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/indexOf.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/insertAt.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/objectAt.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/popObject.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/pushObject.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/rangeObserver.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/removeAt.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/removeObject.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/replace.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/shiftObject.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/debug/test_suites/array/unshiftObject.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/private/observer_set.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/mixins/observable.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/enumerator.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/mixins/enumerable.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/range_observer.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/mixins/array.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/mixins/comparable.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/mixins/copyable.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/mixins/delegate_support.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/mixins/freezable.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/set.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/object.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/private/chain_observer.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/private/observer_queue.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/protocols/observable_protocol.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/protocols/sparse_array_delegate.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/binding.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/error.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/index_set.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/logger.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/run_loop.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/selection_set.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/source/system/sparse_array.js?1256536762"></script>
  <script type="text/javascript" src="/static/sproutcore/runtime/en/current/bundle_loaded.js?0"></script>
<script type="text/javascript">String.preferredLanguage = "en";</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/private/observer_queue/isObservingSuspended.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore Costello - Property Observing Library
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

var callCount, obj;

module("SC.Observers.isObservingSuspended", {
  setup: function() {
    callCount = 0;
    
    obj = SC.Object.create({ 
      foo: "bar",

      fooDidChange: function() { 
        callCount++; 
      }.observes('foo')
    });
  }
});

test("suspending observers stops notification", function() {
  SC.Observers.suspendPropertyObserving();
  SC.Observers.suspendPropertyObserving();
  obj.set("foo");
  equals(callCount, 0, 'should not notify observer while suspended');

  SC.Observers.resumePropertyObserving();
  equals(callCount, 0, 'should not notify observer while still suspended');
  
  SC.Observers.resumePropertyObserving();
  equals(callCount, 1, 'should notify observer when resumed');
  
});

// ..........................................................
// SPECIAL CASES
// 

// this test verifies a specific bug in the SC.Observing.propertyDidChange method.
test("suspended notifications should work when nesting property change groups", function() {
  
  SC.Observers.suspendPropertyObserving();
  obj.beginPropertyChanges();
  obj.set("foo");
  equals(callCount, 0, 'should not notify observer while suspended');

  obj.endPropertyChanges();
  equals(callCount, 0, 'should not notify observer while suspended');

  SC.Observers.resumePropertyObserving();
  equals(callCount, 1, 'should notify observer when resumed');
});
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/set.js"; 
}
(function() {
// ========================================================================
// SC.Set Tests
// ========================================================================
/*globals module test ok isObj equals expects */

var a, b, c ; // global variables

module("creating SC.Set instances", {
  
  setup: function() {
    // create objects...
    a = { name: "a" } ;
    b = { name: "b" } ;
    c = { name: "c" } ;
  },
  
  teardown: function() {
    a = undefined ;
    b = undefined ;
    c = undefined ;
  }
  
});

test("SC.Set.create() should create empty set", function() {
  var set = SC.Set.create() ;
  equals(set.length, 0) ;
});

test("SC.Set.create([1,2,3]) should create set with three items in them", function() {
  var set = SC.Set.create([a,b,c]) ;
  equals(set.length, 3) ;
  equals(set.contains(a), YES) ;
  equals(set.contains(b), YES) ;
  equals(set.contains(c), YES) ;
});

test("SC.Set.create() should accept anything that implements SC.Array", function() {
  var arrayLikeObject = SC.Object.create(SC.Array, {
    _content: [a,b,c],
    length: 3,
    objectAt: function(idx) { return this._content[idx]; } 
  }) ;
  
  var set = SC.Set.create(arrayLikeObject) ;
  equals(set.length, 3) ;
  equals(set.contains(a), YES) ;
  equals(set.contains(b), YES) ;
  equals(set.contains(c), YES) ;
});

var set ; // global variables

// The tests below also end up testing the contains() method pretty 
// exhaustively.
module("SC.Set.add + SC.Set.contains", {
  
  setup: function() {
    set = SC.Set.create() ;
  },
  
  teardown: function() {
    set = undefined ;
  }
  
});

test("should add an SC.Object", function() {
  var obj = SC.Object.create() ;
  
  var oldLength = set.length ;
  set.add(obj) ;
  equals(set.contains(obj), YES, "contains()") ;
  equals(oldLength+1, set.length, "new set length") ;
});

test("should add a regular hash", function() {
  var obj = {} ;
  
  var oldLength = set.length ;
  set.add(obj) ;
  equals(set.contains(obj), YES, "contains()") ;
  equals(oldLength+1, set.length, "new set length") ;
});

test("should add a string", function() {
  var obj = "String!" ;
  
  var oldLength = set.length ;
  set.add(obj) ;
  equals(set.contains(obj), YES, "contains()") ;
  equals(oldLength+1, set.length, "new set length") ;
});

test("should add a number", function() {
  var obj = 23 ;
  
  var oldLength = set.length ;
  set.add(obj) ;
  equals(set.contains(obj), YES, "contains()") ;
  equals(oldLength+1, set.length, "new set length") ;
});

test("should add a bool", function() {
  var obj = true ;
  
  var oldLength = set.length ;
  set.add(obj) ;
  equals(set.contains(obj), YES, "contains()") ;
  equals(oldLength+1, set.length, "new set length") ;
});

test("should add a function", function() {
  var obj = function() { return "Test function"; } ;
  
  var oldLength = set.length ;
  set.add(obj) ;
  equals(set.contains(obj), YES, "contains()") ;
  equals(oldLength+1, set.length, "new set length") ;
});

test("should NOT add a null", function() {
  set.add(null) ;
  equals(set.length, 0) ;
  equals(set.contains(null), NO) ;
});

test("should NOT add an undefined", function() {
  set.add(undefined) ;
  equals(set.length, 0) ;
  equals(set.contains(undefined), NO) ;
});

test("adding an item, removing it, adding another item", function() {
  var item1 = "item1" ;
  var item2 = "item2" ;

  set.add(item1) ; // add to set
  set.remove(item1) ; //remove from set
  set.add(item2) ;
  
  equals(NO, set.contains(item1), "set.contains(item1)") ;
  
  set.add(item1) ; // re-add to set
  equals(2, set.length, "set.length") ;
});

module("SC.Set.remove + SC.Set.contains", {
  
  // generate a set with every type of object, but none of the specific
  // ones we add in the tests below...
  setup: function() {
    set = SC.Set.create([
      SC.Object.create({ dummy: YES }),
      { isHash: YES },
      "Not the String",
      16, false]) ;
  },
  
  teardown: function() {
    set = undefined ;
  }
  
});

test("should remove an SC.Object and reduce length", function() {
  var obj = SC.Object.create() ;
  set.add(obj) ;
  equals(set.contains(obj), YES) ;
  var oldLength = set.length ;
  
  set.remove(obj) ;
  equals(NO, set.contains(obj), "should be removed") ;
  equals(oldLength-1, set.length, "should be 1 shorter") ;
});

test("should remove a regular hash and reduce length", function() {
  var obj = {} ;
  set.add(obj) ;
  equals(set.contains(obj), YES) ;
  var oldLength = set.length ;
  
  set.remove(obj) ;
  equals(NO, set.contains(obj), "should be removed") ;
  equals(oldLength-1, set.length, "should be 1 shorter") ;
});

test("should remove a string and reduce length", function() {
  var obj = "String!" ;
  set.add(obj) ;
  equals(set.contains(obj), YES) ;
  var oldLength = set.length ;
  
  set.remove(obj) ;
  equals(NO, set.contains(obj), "should be removed") ;
  equals(oldLength-1, set.length, "should be 1 shorter") ;
});

test("should remove a number and reduce length", function() {
  var obj = 23 ;
  set.add(obj) ;
  equals(set.contains(obj), YES) ;
  var oldLength = set.length ;
  
  set.remove(obj) ;
  equals(NO, set.contains(obj), "should be removed") ;
  equals(oldLength-1, set.length, "should be 1 shorter") ;
});

test("should remove a bool and reduce length", function() {
  var obj = true ;
  set.add(obj) ;
  equals(set.contains(obj), YES) ;
  var oldLength = set.length ;
  
  set.remove(obj) ;
  equals(NO, set.contains(obj), "should be removed") ;
  equals(oldLength-1, set.length, "should be 1 shorter") ;
});

test("should remove a function and reduce length", function() {
  var obj = function() { return "Test function"; } ;
  set.add(obj) ;
  equals(set.contains(obj), YES) ;
  var oldLength = set.length ;
  
  set.remove(obj) ;
  equals(NO, set.contains(obj), "should be removed") ;
  equals(oldLength-1, set.length, "should be 1 shorter") ;
});

test("should NOT remove a null", function() {
  var oldLength = set.length ;
  set.remove(null) ;
  equals(oldLength, set.length) ;
});

test("should NOT remove an undefined", function() {
  var oldLength = set.length ;
  set.remove(undefined) ;
  equals(oldLength, set.length) ;
});

test("should ignore removing an object not in the set", function() {
  var obj = SC.Object.create() ;
  var oldLength = set.length ;
  set.remove(obj) ;
  equals(oldLength, set.length) ;
});

// test("should remove all the elements in the set", function() {
// 	var obj = [2,3,4];
// 	set.add(obj) ;
// 	var oldLength = set.length ;
// 	equals(6, oldLength);
// 	a = set.removeEach(obj);
// 	equals(0, a.length);
// });

module("SC.Set.pop + SC.Set.clone", {
// generate a set with every type of object, but none of the specific
// ones we add in the tests below...
	setup: function() {
		set = SC.Set.create([
			SC.Object.create({ dummy: YES }),
			{ isHash: YES },
			"Not the String",
			16, false]) ;
		},
		
		teardown: function() {
			set = undefined ;
		}
});

test("the pop() should remove an arbitrary object from the set", function() {
	var oldLength = set.length ;
	var obj = set.pop();
	equals(SC.T_OBJECT,SC.typeOf(obj),'pops up an object');
	equals(oldLength-1,set.length,'length shorter by 1');
});

test("the clone() should return an indentical set", function() {
	var oldLength = set.length ;
	var obj = set.clone();
	equals(oldLength,obj.length,'length of the clone should be same');
	equals(YES,obj.contains(set[0]));
	equals(YES,obj.contains(set[1]));
	equals(YES,obj.contains(set[2]));
	equals(YES,obj.contains(set[3]));
	equals(YES,obj.contains(set[4]));
});
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/sparse_array.js"; 
}
(function() {
// ========================================================================
// SC.SparseArray Tests
// ========================================================================
/*globals module test ok isObj equals expects */
var objectA = 23, objectB = 12, objectC = 31, numbers, new_numbers;
module("SC.SparseArray") ;

test("new SparseArray has expected length", function() {
  var ary = SC.SparseArray.array(10000) ;
  equals(10000, ary.get('length'), "length") ;
});

test("fetching the object at index", function() {
	var ary = SC.SparseArray.create(10);
	var arr = ["I'll","be","there","4u"];
	ary = arr;
	equals(2 ,ary.indexOf('there'), "Index of 'there' is");
});

test("Update the sparse array using provideObjectAtIndex", function() {
	var ary = SC.SparseArray.create(2);
	var obj = "not";
	ary.provideObjectAtIndex(0, obj);
	equals(obj, ary._sa_content[0],"Content at 0th index");
	obj = "now";
	ary.provideObjectAtIndex(1, obj);
	equals(obj, ary._sa_content[1],"Content at 1st index");
});

test("objectAt() should get the object at the specified index",function() {
	var spArray = SC.SparseArray.create(4) ;
	var arr = [SC.Object.create({ dummy: YES }),"Sproutcore",2,true];
	spArray = arr;
	equals(4,spArray.length,'the length');
	equals(arr[0],spArray.objectAt(0),'first object');
	equals(arr[1],spArray.objectAt(1),'second object');
	equals(arr[2],spArray.objectAt(2),'third object');
	equals(arr[3],spArray.objectAt(3),'fourth object');
});

module("SC.replace",{
	setup: function() {
		// create objects...
		numbers= [1,2,3] ;
		new_numbers = [4,5,6];
	}
});

test("element to be added is at idx > length of array ", function() {
	var ary = SC.SparseArray.array(5) ;
	equals(5, ary.get('length'), "length") ;
	ary = numbers;
	ary.replace(7,3,new_numbers,"put the new number at idx>len ");
	equals(6, ary.get('length'), "length") ;
});

test("element to be added is such that amt + idx > length of array ", function() {
	var ary = SC.SparseArray.array(5) ;
	equals(5, ary.get('length'), "length") ;
	ary = numbers;
	ary.replace(4,3,new_numbers,"put the new number at idx < len ");
	equals(6, ary.get('length'), "length") ;
});

test("element to be added is at idx > length of array ", function() {
	var ary = SC.SparseArray.array(5) ;
	equals(5, ary.get('length'), "length") ;
	ary = numbers;
	ary.replace(2,3,new_numbers,"put the new number overlapping existing numbers ");
	equals(5, ary.get('length'), "length") ;
});


test("modifying a range should not require the rest of the array to refetch", function() {
  var del = {
    cnt: 0,
    
    sparseArrayDidRequestIndex: function(sparseArray, idx) {
      this.cnt++;
      sparseArray.provideObjectAtIndex(idx, "foo");
    },
    
    sparseArrayDidRequestLength: function(sparseArray) {
      sparseArray.provideLength(100);
    },
    
    // make editable
    sparseArrayShouldReplace: function() { return YES; }
    
  };
  
  var ary = SC.SparseArray.create({
    delegate: del
  });
  
  equals(ary.objectAt(10), 'foo', 'precond - should provide foo');
  equals(del.cnt, 1, 'precond - should invoke sparseArrayDidRequestIndex() one time');
  
  del.cnt = 0;
  
  ary.removeAt(5); // delete an item before 10
  equals(ary.objectAt(9), 'foo', 'should provide foo at index after delete');
  equals(del.cnt, 0, 'should NOT invoke sparseArrayRequestIndex() since it was provided already');
});

test("Check that requestIndex works with a rangeWindowSize larger than 1", function() {
	var ary = SC.SparseArray.array(10) ;
	var didRequestRange=NO;
	
	var DummyDelegate = SC.Object.extend({
    content: [], // source array

    sparseArrayDidRequestLength: function(sparseArray) {
      sparseArray.provideLength(this.content.length);
    },

    sparseArrayDidRequestIndex: function(sparseArray, index) {
      sparseArray.provideObjectAtIndex(index, this.content[index]);
    },

    sparseArrayDidRequestIndexOf: function(sparseArray, object) {
      return this.content.indexOf(object);    
    },

    sparseArrayShouldReplace: function(sparseArray, idx, amt, objects) {
      this.content.replace(idx, amt, objects) ; // keep internal up-to-date
      return YES ; // allow anything
    },
    sparseArrayDidRequestRange: function(sparseArray, range) {
       didRequestRange=YES;
     }

  });
  ary.set('delegate', DummyDelegate.create());
	ary.set('rangeWindowSize', 4);
	equals(10, ary.get('length'), "length") ;
	ary.objectAt(7);
	equals(didRequestRange, YES, "The range was requested") ;
});


// ..........................................................
// definedIndexes
// 

test("definedIndexes", function() {
  var ary = SC.SparseArray.array(10);
  ary.provideObjectAtIndex(5, "foo");
  
  var expected = SC.IndexSet.create().add(5);
  same(ary.definedIndexes(), expected, 'definedIndexes() should return all defined indexes');
  
  same(ary.definedIndexes(SC.IndexSet.create().add(2, 10)), expected, 'definedIndexes([2..11]) should return indexes within');
  
  same(ary.definedIndexes(SC.IndexSet.create().add(2)), SC.IndexSet.EMPTY, 'definedIndexes([2]) should return empty set (since does not overlap with defined index)');
  
});

// ..........................................................
// TEST SC.ARRAY COMPLIANCE
// 

var DummyDelegate = SC.Object.extend({
  content: [], // source array

  sparseArrayDidRequestLength: function(sparseArray) {
    sparseArray.provideLength(this.content.length);
  },
  
  sparseArrayDidRequestIndex: function(sparseArray, index) {
    sparseArray.provideObjectAtIndex(index, this.content[index]);
  },
  
  sparseArrayDidRequestIndexOf: function(sparseArray, object) {
    return this.content.indexOf(object);    
  },
  
  sparseArrayShouldReplace: function(sparseArray, idx, amt, objects) {
    this.content.replace(idx, amt, objects) ; // keep internal up-to-date
    return YES ; // allow anything
  }
  
});

SC.ArraySuite.generate("SC.SparseArray", {
  newObject: function(amt) {
    if (amt === undefined || typeof amt === SC.T_NUMBER) {
      amt = this.expected(amt);
    }

    var del = DummyDelegate.create({ content: amt });
    return SC.SparseArray.create({ delegate: del });
  }
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/logger.js"; 
}
(function() {
// ==========================================================================
// SC.Logger Unit Test
// ==========================================================================

/*globals module test equals */


// Test console needed because testing for null functions,
// ie. setting the actual console.log = null means setting up
// and tearing down no longer work properly.

function testConsole() {
  return {
    log: function() { return true; },
    alert: function() { return true; },
    dir: function() { return true; },
    dirxml: function() { return true; },
    error: function() { return true; },
    group: function() { return true; },
    groupEnd: function() { return true; },
    info: function() { return true; },
    profile: function() { return true; },
    profileEnd: function() { return true; },
    time: function() { return true; },
    timeEnd: function() { return true; },
    trace: function() { return true; },
    warn: function() { return true; }
  };
};

module("SC.Logger", {
  setup: function() {
    SC.Logger.set('reporter', testConsole());
    
    SC.Logger.format = true;
    SC.Logger.fallBackOnLog = true;
    SC.Logger.fallBackOnAlert = false;
  },
  teardown: function() {
  }
});

test("exists", function() {
  equals(SC.Logger.get('exists'), true, "Reporter does exist check");
  
  SC.Logger.set('reporter', null);
  equals(SC.Logger.get('exists'), false, "Reporter does not exist check");
});

test("log", function() {
  equals(SC.Logger.log("test"), true, "Function is defined" );
  
  var reporter = SC.Logger.get('reporter');
  reporter.log = null;
  equals(SC.Logger.log("test"), false, "Function is null");
  
  SC.Logger.fallBackOnAlert = true;
  equals(SC.Logger.log("test"), true, "Function is null -- fallBackOnAlert true");
});

test("dir", function() {
  equals(SC.Logger.dir({test:"string"}), true, "Function is defined");
  
  SC.Logger.get('reporter').dir = null;
  equals(SC.Logger.dir({test:"string"}), true, "Function is null -- fallBackOnLog true");
  
  SC.Logger.fallBackOnLog = false;
  equals(SC.Logger.dir({test:"string"}), false, "Function is null -- fallBackOnLog false");
});

test("dirxml", function() {
  equals(SC.Logger.dirxml("<here id='2'>is some XML</here>"), true, "Function is defined");
  
  SC.Logger.get('reporter').dirxml = null;
  equals(SC.Logger.dirxml("<here id='2'>is some XML</here>"), true, "Function is null -- fallBackOnLog true");
  
  SC.Logger.fallBackOnLog = false;
  equals(SC.Logger.dirxml("<here id='2'>is some XML</here>"), false, "Function is null -- fallBackOnLog false");
});

test("error", function() {
  equals(SC.Logger.error("Error"), true, "Function is defined");
  
  SC.Logger.get('reporter').error = null;
  equals(SC.Logger.error("Error"), true, "Function is null -- fallBackOnLog true");

  SC.Logger.fallBackOnLog = false;
  equals(SC.Logger.error("Error"), false, "Function is null -- fallBackOnLog false");
});

test("group", function() {
  equals(SC.Logger.group("mygroup"), true, "Function is defined");
  
  SC.Logger.get('reporter').group = null;
  equals(SC.Logger.group("mygroup"), false, "Function is null");
});

test("groupEnd", function() {
  equals(SC.Logger.groupEnd("mygroup"), true, "Function is defined");
  
  SC.Logger.get('reporter').groupEnd = null;
  equals(SC.Logger.groupEnd("mygroup"), false, "Function is null");
});

test("info", function() {
  equals(SC.Logger.info("Info"), true, "Function is defined");
  
  SC.Logger.get('reporter').info = null;
  equals(SC.Logger.info("Info"), true, "Function is null -- fallBackOnLog true");

  SC.Logger.fallBackOnLog = false;
  equals(SC.Logger.info("Info"), false, "Function is null -- fallBackOnLog false");
});

test("profile", function() {
  equals(SC.Logger.profile(), true, "Function is defined");
  
  SC.Logger.get('reporter').profile = null;
  equals(SC.Logger.profile(), false, "Function is null");
});

test("profileEnd", function() {
  equals(SC.Logger.profileEnd(), true, "Function is defined");
  
  SC.Logger.get('reporter').profileEnd = null;
  equals(SC.Logger.profileEnd(), false, "Function is null");
});

test("time", function() {
  equals(SC.Logger.time('mytime'), true, "Function is defined");
  
  SC.Logger.get('reporter').time = null;
  equals(SC.Logger.time('mytime'), false, "Function is null");
});

test("timeEnd", function() {
  equals(SC.Logger.timeEnd('mytime'), true, "Function is defined");
  
  SC.Logger.get('reporter').timeEnd = null;
  equals(SC.Logger.timeEnd('mytime'), false, "Function is null");
});

test("trace", function() {
  equals(SC.Logger.trace(), true, "Function is defined");
  
  SC.Logger.get('reporter').trace = null;
  equals(SC.Logger.trace(), false, "Function is null");
});

test("warn", function() {
  equals(SC.Logger.warn("Warn"), true, "Function is defined");
  
  SC.Logger.get('reporter').warn = null;
  equals(SC.Logger.warn("Warn"), true, "Function is null -- fallBackOnLog true");

  SC.Logger.fallBackOnLog = false;
  equals(SC.Logger.warn("Warn"), false, "Function is null -- fallBackOnLog false");
});

test("_argumentsToString", function() {
  equals(SC.Logger._argumentsToString.apply(SC.Logger, ["test", "test2"]), "test" + SC.LOGGER_LOG_DELIMITER + "test2", "Formatting using default delimiter");
  
  SC.LOGGER_LOG_DELIMITER = "|";
  equals(SC.Logger._argumentsToString.apply(SC.Logger, ["test", "test2"]), "test|test2", "Formatting using custom delimiter");
});
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/intersects.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

var set ;
module("SC.IndexSet#intersects", {
  setup: function() {
    set = SC.IndexSet.create().add(1000, 10).add(2000,1);
  }
});

// ..........................................................
// SINGLE INDEX
// 

test("handle index in set", function() {
  equals(set.intersects(1001), YES, 'index 1001 should be in set %@'.fmt(set));
  equals(set.intersects(1009), YES, 'index 1009 should be in set %@'.fmt(set));
  equals(set.intersects(2000), YES, 'index 2000 should be in set %@'.fmt(set));
});

test("handle index not in set", function() {
  equals(set.intersects(0), NO, 'index 0 should not be in set');
  equals(set.intersects(10), NO, 'index 10 should not be in set');
  equals(set.intersects(1100), NO, 'index 1100 should not be in set');
});

test("handle index past end of set", function() {
  equals(set.intersects(3000), NO, 'index 3000 should not be in set');
});

// ..........................................................
// RANGE
// 

test("handle range inside set", function() {
  equals(set.intersects(1001,4), YES, '1001..1003 should be in set');
});

test("handle range outside of set", function() {
  equals(set.intersects(100,4), NO, '100..1003 should NOT be in set');
});

test("handle range partially inside set", function() {
  equals(set.intersects(998,4), YES,'998..1001 should be in set');
});

// ..........................................................
// INDEX SET
// 

test("handle set inside set", function() {
  var test = SC.IndexSet.create().add(1001,4).add(1005,2);
  equals(set.intersects(test), YES, '%@ should be in %@'.fmt(test, set));
});

test("handle range outside of set", function() {
  var test = SC.IndexSet.create().add(100,4).add(105,2);
  equals(set.intersects(test), NO, '%@ should be in %@'.fmt(test, set));
});

test("handle range partially inside set", function() {
  var test = SC.IndexSet.create().add(1001,4).add(100,2);
  equals(set.intersects(test), YES, '%@ should be in %@'.fmt(test, set));
});

test("handle self", function() {
  equals(set.contains(set), YES, 'should return YES when passed itself');  
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/clone.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */
var set ;
module("SC.IndexSet#clone", {
  setup: function() {
    set = SC.IndexSet.create();
  }
});

test("clone should return new object with same key properties", function() {
  set.add(100,100).add(200,100);
  set.source = "foo";
  
  var set2 = set.clone();
  ok(set2 !== null, 'return value should not be null');
  ok(set2 !== set, 'cloned set should not be same instance as set');
  ok(set.isEqual(set2), 'set.isEqual(set2) should be true');
  
  equals(set2.get('length'), set.get('length'), 'clone should have same length');
  equals(set2.get('min'), set.get('min'), 'clone should have same min');
  equals(set2.get('max'), set.get('max'), 'clone should have same max');
  equals(set2.get('source'), set.get('source'), 'clone should have same source');

});

test("cloning frozen object returns unfrozen", function() {
  var set2 = set.freeze().clone();
  equals(set2.get('isFrozen'), NO, 'set2.isFrozen should be NO');
});

test("copy works like clone", function() {
  same(set.copy(), set, 'should return copy');
  ok(set.copy() !== set, 'should not return same instance');
  
  set.freeze();
  equals(set.frozenCopy(), set, 'should return same instance when frozen');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/remove.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest should_throw*/
var set ;
module("SC.IndexSet#remove", {
  setup: function() {
    set = SC.IndexSet.create();
  }
});

function iter(s) {
  var ret = [];
  set.forEach(function(k) { ret.push(k); });
  return ret ;
}

// ..........................................................
// BASIC REMOVES
// 

test("remove a range after end of set", function() {
  equals(set.get('length'), 0, 'precond - should be empty');  

  set.remove(1000, 5);
  equals(set.get('length'), 0, 'should still be empty');  
  equals(set.get('max'), 0, 'max should return 1 past last index');
  same(iter(set), [], 'should be empty');
});

test("remove range in middle of an existing range", function() {
  set.add(100,4);
  same(iter(set), [100, 101, 102, 103], 'precond - should have range');
  
  set.remove(101,2);
  equals(set.get('length'), 2, 'new length should not include removed range');
  equals(set.get('max'), 104, 'max should return 1 past last index');
  same(iter(set), [100,103], 'should remove range in the middle'); 
});

test("remove range overlapping front edge of range", function() {
  set.add(100,2); // add initial set.
  equals(iter(set)[0], 100, 'precond - first index is 100');
  
  // now add second range
  set.remove(99,2);
  equals(set.get('length'), 1, 'should have extra length');
  equals(set.get('max'), 102, 'max should return 1 past last index');
  same(iter(set), [101]);
});

test("remove range overlapping last edge of range", function() {
  set.add(100,2).add(200,2); // make sure not last range
  same(iter(set), [100,101,200,201], 'should have two sets');
  
  // now add overlapping range
  set.remove(101,2);
  equals(set.get('length'), 3, 'new set.length');
  equals(set.get('max'), 202, 'max should return 1 past last index');
  same(iter(set), [100,200,201], 'should remove 101-102');
});

test("remove range overlapping two ranges, remove parts of both", function() {
  set.add(100,2).add(110,2);
  same(iter(set), [100,101,110,111], 'should have two sets');
  
  // now add overlapping range
  set.remove(101,10);
  equals(set.get('length'), 2, 'new set.length');
  equals(set.get('max'), 112, 'max should return 1 past last index');
  same(iter(set), [100,111], 'should remove range 101-110');
});

test("remove range overlapping three ranges, removing one and parts of the others", function() {
  set.add(100,2).add(105,2).add(110,2);
  same(iter(set), [100,101,105,106,110,111], 'should have two sets');
  
  // now add overlapping range
  set.remove(101,10);
  equals(set.get('length'), 2, 'new set.length');
  equals(set.get('max'), 112, 'max should return 1 past last index');
  same(iter(set), [100,111], 'should remove range 101-110');
});

test("remove range partially overlapping one range and replacing another range", function() {
  set.add(100,2).add(105,2);
  same(iter(set), [100,101,105,106], 'should have two sets');
  
  // now add overlapping range
  set.remove(101,10);
  equals(set.get('length'), 1, 'new set.length');

  equals(set.get('max'), 101, 'max should return 1 past last index');
  same(iter(set), [100], 'should include one range 100-110');
});

test("remove range overlapping last index", function() {
  set.add(100,2); // add initial set.
  equals(iter(set)[0], 100, 'precond - first index is 100');
  
  // now add second range
  set.remove(101,2);
  equals(set.get('length'), 1, 'should have extra length');
  equals(set.get('max'), 101, 'max should return 1 past last index');
  same(iter(set), [100]);
});

test("remove range matching existing range", function() {
  set.add(100,5); // add initial set.
  same(iter(set), [100, 101, 102, 103, 104]);
  
  // now add second range
  set.remove(100,5);
  equals(set.get('length'), 0, 'should be empty');
  equals(set.get('max'), 0, 'max should return 1 past last index');
  same(iter(set), []);  
});

// ..........................................................
// NORMALIZED PARAMETER CASES
// 

test("remove with no params should do nothing", function() {
  set.add(10,2).remove();
  same(iter(set), [10,11]);
});

test("remove with single number should add index only", function() {
  set.add(10,2).remove(10);
  same(iter(set), [11]);
});

test("remove with range object should add range only", function() {
  set.add(10,5).remove({ start: 10, length: 2 });
  same(iter(set), [12,13,14]);
});

test("remove with index set should add indexes in set", function() {
  set.add(0,14).remove(SC.IndexSet.create().add(2,2).add(10,2));
  same(iter(set), [0,1,4,5,6,7,8,9,12,13]);
});


// ..........................................................
// OTHER BEHAVIORS
// 
test("remove a range should trigger an observer notification", function() {
  var callCnt = 0;
  set.add(10, 20);
  
  set.addObserver('[]', function() { callCnt++; });
  set.remove(10,10);
  equals(callCnt, 1, 'should have called observer once');
});

test("removing a non-existant range should not trigger observer notification", function() {
  var callCnt = 0;
  
  set.addObserver('[]', function() { callCnt++; });
  set.remove(10,10); // 10-20 are already empty
  equals(callCnt, 0, 'should NOT have called observer');
});

test("removing a clone of the same index set should leave an empty set", function() {
  var set = SC.IndexSet.create(0,2), set2 = set.clone();
  ok(set.isEqual(set2), 'precond - clone is equal to receiver');
  set.remove(set2);
  equals(set.get('length'), 0, 'set should now be empty');
});

test("removing an index range outside of target range (specific bug)", function() {

  var set = SC.IndexSet.create(10,3);
  var set2 = SC.IndexSet.create(0,3);
  
  // removing set2 from set should not changed set at all beceause it is 
  // before the first range, but it causes a problem with the length.
  set.remove(set2);
  equals(set.get('length'), 3, 'length should not change');
});

test("remove() raises exception when frozen", function() {
  should_throw(function() {
    set.freeze().remove(0,2);    
  }, SC.FROZEN_ERROR);  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/contains.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

var set ;
module("SC.IndexSet#contains", {
  setup: function() {
    set = SC.IndexSet.create().add(1000, 10).add(2000,1);
  }
});

// ..........................................................
// SINGLE INDEX
// 

test("handle index in set", function() {
  equals(set.contains(1001), YES, 'index 1001 should be in set %@'.fmt(set));
  equals(set.contains(1009), YES, 'index 1009 should be in set %@'.fmt(set));
  equals(set.contains(2000), YES, 'index 2000 should be in set %@'.fmt(set));
});

test("handle index not in set", function() {
  equals(set.contains(0), NO, 'index 0 should not be in set');
  equals(set.contains(10), NO, 'index 10 should not be in set');
  equals(set.contains(1100), NO, 'index 1100 should not be in set');
});

test("handle index past end of set", function() {
  equals(set.contains(3000), NO, 'index 3000 should not be in set');
});

// ..........................................................
// RANGE
// 

test("handle range inside set", function() {
  equals(set.contains(1001,4), YES, '1001..1003 should be in set');
});

test("handle range outside of set", function() {
  equals(set.contains(100,4), NO, '100..1003 should NOT be in set');
});

test("handle range partially inside set", function() {
  equals(set.contains(998,4), NO,'998..1001 should be in set');
});

// ..........................................................
// INDEX SET
// 

test("handle set inside set", function() {
  var test = SC.IndexSet.create().add(1001,4).add(1005,2);
  equals(set.contains(test), YES, '%@ should be in %@'.fmt(test, set));
});

test("handle range outside of set", function() {
  var test = SC.IndexSet.create().add(100,4).add(105,2);
  equals(set.contains(test), NO, '%@ should be in %@'.fmt(test, set));
});

test("handle range partially inside set", function() {
  var test = SC.IndexSet.create().add(1001,4).add(100,2);
  equals(set.contains(test), NO, '%@ should be in %@'.fmt(test, set));
});

test("handle self", function() {
  equals(set.contains(set), YES, 'should return YES when passed itself');  
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/add.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same should_throw*/
var set ;
module("SC.IndexSet#add", {
  setup: function() {
    set = SC.IndexSet.create();
  }
});

function iter(s) {
  var ret = [];
  set.forEach(function(k) { ret.push(k); });
  return ret ;
}

// ..........................................................
// BASIC ADDS
// 

test("add range to end of set", function() {
  set.add(1000,5);
  equals(set.get('length'), 5, 'should have correct index count');  
  equals(set.get('max'), 1005, 'max should return 1 past last index');
  same(iter(set), [1000,1001,1002,1003,1004]);
});

test("add range into middle of empty range", function() {
  set.add(100,2); // add initial set.
  equals(iter(set)[0], 100, 'precond - first index is 100');
  
  // now add second range
  set.add(10,1);
  equals(set.get('length'), 3, 'should have extra length');
  equals(set.get('max'), 102, 'max should return 1 past last index');
  same(iter(set), [10, 100, 101]);
});

test("add range overlapping front edge of range", function() {
  set.add(100,2); // add initial set.
  equals(iter(set)[0], 100, 'precond - first index is 100');
  
  // now add second range
  set.add(99,2);
  equals(set.get('length'), 3, 'should have extra length');
  equals(set.get('max'), 102, 'max should return 1 past last index');
  same(iter(set), [99, 100, 101]);
});

test("add range overlapping last edge of range", function() {
  set.add(100,2).add(200,2);
  same(iter(set), [100,101,200,201], 'should have two sets');
  
  // now add overlapping range
  set.add(101,2);
  equals(set.get('length'), 5, 'new set.length');
  equals(set.get('max'), 202, 'max should return 1 past last index');
  same(iter(set), [100,101,102,200,201], 'should include 101-102');
});

test("add range overlapping two ranges, merging into one", function() {
  set.add(100,2).add(110,2);
  same(iter(set), [100,101,110,111], 'should have two sets');
  
  // now add overlapping range
  set.add(101,10);
  equals(set.get('length'), 12, 'new set.length');
  equals(set.get('max'), 112, 'max should return 1 past last index');
  same(iter(set), [100,101,102,103,104,105,106,107,108,109,110,111], 'should include one range 100-111');
});

test("add range overlapping three ranges, merging into one", function() {
  set.add(100,2).add(105,2).add(110,2);
  same(iter(set), [100,101,105,106,110,111], 'should have two sets');
  
  // now add overlapping range
  set.add(101,10);
  equals(set.get('length'), 12, 'new set.length');
  equals(set.get('max'), 112, 'max should return 1 past last index');
  same(iter(set), [100,101,102,103,104,105,106,107,108,109,110,111], 'should include one range 100-111');
});

test("add range partially overlapping one range and replaing another range, merging into one", function() {
  set.add(100,2).add(105,2);
  same(iter(set), [100,101,105,106], 'should have two sets');
  
  // now add overlapping range
  set.add(101,10);
  equals(set.get('length'), 11, 'new set.length');

  equals(set.get('max'), 111, 'max should return 1 past last index');
  same(iter(set), [100,101,102,103,104,105,106,107,108,109,110], 'should include one range 100-110');
});

test("add range overlapping last index", function() {
  set.add(100,2); // add initial set.
  equals(iter(set)[0], 100, 'precond - first index is 100');
  
  // now add second range
  set.add(101,2);
  equals(set.get('length'), 3, 'should have extra length');
  equals(set.get('max'), 103, 'max should return 1 past last index');
  same(iter(set), [100, 101, 102]);
});

test("add range matching existing range", function() {
  set.add(100,5); // add initial set.
  equals(iter(set)[0], 100, 'precond - first index is 100');
  
  // now add second range
  set.add(100,5);
  equals(set.get('length'), 5, 'should not change');
  equals(set.get('max'), 105, 'max should return 1 past last index');
  same(iter(set), [100, 101, 102, 103, 104]);  
});

// ..........................................................
// NORMALIZED PARAMETER CASES
// 

test("add with no params should do nothing", function() {
  set.add();
  same(iter(set), []);
});

test("add with single number should add index only", function() {
  set.add(2);
  same(iter(set), [2]);
});

test("add with range object should add range only", function() {
  set.add({ start: 2, length: 2 });
  same(iter(set), [2,3]);
});

test("add with index set should add indexes in set", function() {
  set.add(SC.IndexSet.create().add(2,2).add(10,2));
  same(iter(set), [2,3,10,11]);
});

// ..........................................................
// OTHER BEHAVIORS
// 

test("adding a range should trigger an observer notification", function() {
  var callCnt = 0;
  set.addObserver('[]', function() { callCnt++; });
  set.add(10,10);
  equals(callCnt, 1, 'should have called observer once');
});

test("adding a range over an existing range should not trigger an observer notification", function() {
  var callCnt = 0;
  set.add(10,10);
  set.addObserver('[]', function() { callCnt++; });
  set.add(15,5);
  equals(callCnt, 0, 'should not have called observer');
});

test("appending a range to end should merge into last range", function() {
  set = SC.IndexSet.create(2).add(3);
  equals(set.rangeStartForIndex(3), 2, 'last two range should merge together (%@)'.fmt(set.inspect()));
  equals(set.get('max'), 4, 'should have max');
  equals(set.get('length'), 2, 'should have length');

  set = SC.IndexSet.create(2000, 1000).add(3000, 1000);
  equals(set.rangeStartForIndex(3990), 2000, 'last two range should merge together (%@)'.fmt(set.inspect()));
  equals(set.get('max'), 4000, 'should have max');
  equals(set.get('length'), 2000, 'should have length');
  
});

test("appending range to start of empty set should create a single range", function() {
  set = SC.IndexSet.create().add(0,2);
  equals(set.rangeStartForIndex(1), 0, 'should have single range (%@)'.fmt(set.inspect()));
  equals(set.get('length'), 2, 'should have length');
  equals(set.get('max'), 2, 'should have max');
  
  set = SC.IndexSet.create().add(0,2000);
  equals(set.rangeStartForIndex(1998), 0, 'should have single range (%@)'.fmt(set.inspect()));
  equals(set.get('length'), 2000, 'should have length');
  equals(set.get('max'), 2000, 'should have max');
  
});

test("add raises exception when frozen", function() {
  should_throw(function() {
    set.freeze().add(0,2);    
  }, SC.FROZEN_ERROR);  
});

// ..........................................................
// SPECIAL CASES
// 
// demonstrate fixes for specific bugs here.

test("adding in the same range should keep length consistent", function() {
  set = SC.IndexSet.create();
  set.add(1,4);
  equals(set.length, 4, 'set length should be 4');
  
  set.add(1,3); // should be like a no-op
  equals(set.length, 4, 'set length should remain 4 after set.add(1,3)');

  set.add(1,2); // should be like a no-op
  equals(set.length, 4, 'set length should remain 4 after set.add(1,2)');
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/removeEach.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same */
var set ;
module("SC.IndexSet#addEach", {
  setup: function() {
    set = SC.IndexSet.create().add(1000,2).add(1010).add(1020).add(1030);
  }
});

function iter(s) {
  var ret = [];
  set.forEach(function(k) { ret.push(k); });
  return ret ;
}

// ..........................................................
// BASIC ADDS
// 

test("should iterate over an array", function() {
  set.removeEach([1000, 1010, 1020, 1030]);
  equals(set.get('length'), 1, 'should have correct index count');  
  equals(set.get('max'), 1002, 'max should return 1 past last index');
  same(iter(set), [1001]);
});

test("adding should iterate over a set", function() {
  // add out of order...
  var input = SC.Set.create().add(1030).add(1010).add(1020).add(1000);
  set.removeEach(input);
  equals(set.get('length'), 1, 'should have correct index count');  
  equals(set.get('max'), 1002, 'max should return 1 past last index');
  same(iter(set), [1001]);
});


test("adding should iterate over a indexset", function() {
  // add out of order...
  var input = SC.IndexSet.create().add(1000).add(1010).add(1020).add(1030);
  set.removeEach(input);
  equals(set.get('length'), 1, 'should have correct index count');  
  equals(set.get('max'), 1002, 'max should return 1 past last index');
  same(iter(set), [1001]);
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/addEach.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same */
var set ;
module("SC.IndexSet#addEach", {
  setup: function() {
    set = SC.IndexSet.create();
  }
});

function iter(s) {
  var ret = [];
  set.forEach(function(k) { ret.push(k); });
  return ret ;
}

// ..........................................................
// BASIC ADDS
// 

test("adding should iterate over an array", function() {
  set.addEach([1000, 1010, 1020, 1030]);
  equals(set.get('length'), 4, 'should have correct index count');  
  equals(set.get('max'), 1031, 'max should return 1 past last index');
  same(iter(set), [1000, 1010, 1020, 1030]);
});

test("adding should iterate over a set", function() {
  // add out of order...
  var input = SC.Set.create().add(1030).add(1010).add(1020).add(1000);
  set.addEach(input);
  equals(set.get('length'), 4, 'should have correct index count');  
  equals(set.get('max'), 1031, 'max should return 1 past last index');
  same(iter(set), [1000, 1010, 1020, 1030]);
});


test("adding should iterate over a indexset", function() {
  // add out of order...
  var input = SC.IndexSet.create().add(1000,2).add(1010).add(1020).add(1030);
  set.addEach(input);
  equals(set.get('length'), 5, 'should have correct index count');  
  equals(set.get('max'), 1031, 'max should return 1 past last index');
  same(iter(set), [1000, 1001, 1010, 1020, 1030]);
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/create.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

module("SC.IndexSet#create");

test("create with no params", function() {
  var set = SC.IndexSet.create();
  equals(set.get('length'), 0, 'should have no indexes');
});

test("create with just index", function() {
  var set = SC.IndexSet.create(4);
  equals(set.get('length'),1, 'should have 1 index');
  equals(set.contains(4), YES, 'should contain index');
  equals(set.contains(5), NO, 'should not contain 5');
});

test("create with index and length", function() {
  var set = SC.IndexSet.create(4, 2);
  equals(set.get('length'),2, 'should have 2 indexes');
  equals(set.contains(4), YES, 'should contain 4');
  equals(set.contains(5), YES, 'should contain 5');
});

test("create with other set", function() {
  var first = SC.IndexSet.create(4,2);

  var set = SC.IndexSet.create(first);
  equals(set.get('length'),2, 'should have same number of indexes (2)');
  equals(set.contains(4), YES, 'should contain 4, just like first');
  equals(set.contains(5), YES, 'should contain 5, just like first');
});






})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/rangeStartForIndex.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same */
var set, start, len ;
module("SC.IndexSet#rangeStartForIndex", {
  setup: function() {
    start = SC.IndexSet.HINT_SIZE*2 + 10 ;
    len  = Math.floor(SC.IndexSet.HINT_SIZE * 1.5);
    set = SC.IndexSet.create().add(start, len);
  }
});

test("index is start of range", function() {
  equals(set.rangeStartForIndex(start), start, 'should return start');
  equals(set.rangeStartForIndex(0), 0, 'should return first range');
});

test("index is middle of range", function() {
  equals(set.rangeStartForIndex(start+20), start, 'should return start');
  equals(set.rangeStartForIndex(start+SC.IndexSet.HINT_SIZE), start, 'should return start');
  equals(set.rangeStartForIndex(20), 0, 'should return first range');
});

test("index last index", function() {
  equals(set.rangeStartForIndex(start+len), start+len, 'should return end of range');
});

test("index past last index", function() {
  equals(set.rangeStartForIndex(start+len+20), start+len, 'should return end of range');
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/indexBefore.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore Costello - Property Observing Library
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

var set ;

module("SC.IndexSet.indexBefore", {
  setup: function() {
    set = SC.IndexSet.create(5).add(10,5).add(100);
  }
});

test("no earlier index in set", function(){ 
  equals(set.indexBefore(4), -1, 'set.indexBefore(4) in %@ should not have index before it'.fmt(set));
});

test("with index after end of set", function() {
  equals(set.indexBefore(1000), 100, 'set.indexBefore(1000) in %@ should return last index in set'.fmt(set));
});

test("inside of multi-index range", function() {
  equals(set.indexBefore(12), 11, 'set.indexBefore(12) in %@ should return previous index'.fmt(set));
});

test("beginning of multi-index range", function() {
  equals(set.indexBefore(10), 5, 'set.indexBefore(10) in %@ should end of previous range'.fmt(set));
});


test("single index range", function() {
  equals(set.indexBefore(100), 14, 'set.indexBefore(100) in %@ should end of previous range multi-index range'.fmt(set));
});




})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/min.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

module("SC.IndexSet#min");

test("newly created index", function() {
  var set = SC.IndexSet.create();
  equals(set.get('min'), -1, 'min should be -1');
});

test("after adding one range", function() {
  var set = SC.IndexSet.create().add(4,2);
  equals(set.get('min'),4, 'min should be lowest index');
});

test("after adding range then removing part of range", function() {
  var set = SC.IndexSet.create().add(4,4).remove(2,4);
  equals(set.get('min'),6, 'min should be lowest index');
});

test("after adding range several disjoint ranges", function() {
  var set = SC.IndexSet.create().add(6000).add(4,4);
  equals(set.get('min'),4, 'min should be lowest index');
});

test("after removing disjoint range", function() {
  var set = SC.IndexSet.create().add(4,2).add(6000).remove(2,10);
  equals(set.get('min'),6000, 'min should be lowest index');
});

test("after removing all ranges", function() {
  var set = SC.IndexSet.create().add(4,2).add(6000).remove(3,6200);
  equals(set.get('min'), -1, 'min should be back to -1 with no content');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/without.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */
var set, ret ;
module("SC.IndexSet#without", {
  setup: function() {
    set = SC.IndexSet.create(1,9);
  }
});

function iter(s) {
  var ret = [];
  s.forEach(function(k) { ret.push(k); });
  return ret ;
}

test("should return empty set when removing self", function() {
  ret = set.without(set);
  ok(ret !== set, 'is not same instance');
  same(iter(ret), []);
});

test("should return set with range removed from middle", function() {
  ret = SC.IndexSet.create(2,6);
  ret = set.without(ret);
  ok(ret !== set, 'is not same instance');
  same(iter(ret), [1,8,9]);
});

test("should return set with range removed overlapping end", function() {
  ret = set.without(SC.IndexSet.create(6,6));
  ok(ret !== set, 'is not same instance');
  same(iter(ret), [1,2,3,4,5]);
});

test("should return set with range removed overlapping beginning", function() {
  ret = set.without(SC.IndexSet.create(0,6));
  ok(ret !== set, 'is not same instance');
  same(iter(ret), [6,7,8,9]);
});


test("should return set with multiple ranges removed", function() {
  ret = set.without(SC.IndexSet.create(2,2).add(6,2));
  ok(ret !== set, 'is not same instance');
  same(iter(ret), [1,4,5,8,9]);
});

test("using without should properly hint returned index set", function() {
  var set = SC.IndexSet.create(10000,5),
      set2 = SC.IndexSet.create(10000),
      actual = set.without(set2),
      loc = SC.IndexSet.HINT_SIZE;
      
  while(loc<2000) { // spot check
    equals(actual._content[loc], 0, 'index set should have hint at loc %@ - set: %@'.fmt(loc, actual.inspect()));
    loc += SC.IndexSet.HINT_SIZE;
  }
});

// ..........................................................
// NORMALIZED PARAMETER CASES
// 

test("passing no params should return clone", function() {
  ret = set.without();
  ok(ret !== set, 'is not same instance');
  ok(ret.isEqual(set), 'has same content');
});

test("passing single number should remove just that index", function() {
  ret = set.without(5);
  same(iter(ret), [1,2,3,4,6,7,8,9]);
});

test("passing two numbers should remove range", function() {
  ret = set.without(2,6);
  same(iter(ret), [1,8,9]);
});

test("passing range object should remove range", function() {
  ret = set.without({ start: 2, length: 6 });
  same(iter(ret), [1,8,9]);
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/indexAfter.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore Costello - Property Observing Library
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

var set ;

module("SC.IndexSet.indexAfter", {
  setup: function() {
    set = SC.IndexSet.create(5).add(10,5).add(100);
  }
});

test("no earlier index in set", function(){ 
  equals(set.indexAfter(3), 5, 'set.indexAfter(3) in %@ should start of first index range'.fmt(set));
});

test("with index after end of set", function() {
  equals(set.indexAfter(1000), -1, 'set.indexAfter(1000) in %@ should return -1'.fmt(set));
});

test("inside of multi-index range", function() {
  equals(set.indexAfter(12), 13, 'set.indexAfter(12) in %@ should return next index'.fmt(set));
});

test("end of multi-index range", function() {
  equals(set.indexAfter(14), 100, 'set.indexAfter(14) in %@ should start of next range'.fmt(set));
});


test("single index range", function() {
  equals(set.indexAfter(5), 10, 'set.indexAfter(5) in %@ should start of next range multi-index range'.fmt(set));
});




})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/index_set/max.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

module("SC.IndexSet#max");

test("newly created index", function() {
  var set = SC.IndexSet.create();
  equals(set.get('max'), 0, 'max should be 0');
});

test("after adding one range", function() {
  var set = SC.IndexSet.create().add(4,2);
  equals(set.get('max'),6, 'max should be one greater than max index');
});

test("after adding range then removing part of range", function() {
  var set = SC.IndexSet.create().add(4,4).remove(6,4);
  equals(set.get('max'),6, 'max should be one greater than max index');
});

test("after adding range several disjoint ranges", function() {
  var set = SC.IndexSet.create().add(4,4).add(6000);
  equals(set.get('max'),6001, 'max should be one greater than max index');
});

test("after removing disjoint range", function() {
  var set = SC.IndexSet.create().add(4,2).add(6000).remove(5998,10);
  equals(set.get('max'),6, 'max should be one greater than max index');
});

test("after removing all ranges", function() {
  var set = SC.IndexSet.create().add(4,2).add(6000).remove(3,6200);
  equals(set.get('max'), 0, 'max should be back to 0 with no content');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/range_observer/update.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

var source, indexes, observer, obj ; // base array to work with
module("SC.RangeObserver#update", {
  setup: function() {
    
    // create array with 5 SC.Object's in them
    source = [1,2,3,4,5].map(function(x) {
      return SC.Object.create({ item: x, foo: "bar" }) ;
    }, this); 

    indexes = SC.IndexSet.create(2,2); // select 2..3
    
    observer = SC.Object.create({
      
      callCount: 0, 
      
      rangeDidChange: function() { 
        this.callCount++;
      }
      
    });

    obj = SC.RangeObserver.create(source, indexes, observer, observer.rangeDidChange, "context", YES);
    
  }
});

test("returns receiver", function() {
  ok(obj === obj.update(source, SC.IndexSet.create()), 'should return receiver');
});

test("switches to observing new range - no previous updated", function() {
  obj.update(source, SC.IndexSet.create(0));
  observer.callCount = 0 ;
  
  var len = source.length, idx;
  for(idx=0;idx<len;idx++) source[idx].set('foo', 'baz');
  
  // since new index set length is different use this as a proxy to verify
  // that range changed
  equals(observer.callCount, 1, 'range observer should fire on new range');
});

test("switches to observing new range - previously updated", function() {
  var len = source.length, idx;
  for(idx=0;idx<len;idx++) source[idx].set('foo', 'baz');
  observer.callCount = 0 ;

  obj.update(source, SC.IndexSet.create(0));
  observer.callCount = 0 ;
  
  for(idx=0;idx<len;idx++) source[idx].set('foo', 'bar');
  
  // since new index set length is different use this as a proxy to verify
  // that range changed
  equals(observer.callCount, 1, 'range observer should fire on new range');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/range_observer/destroy.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

var source, indexes, observer, obj ; // base array to work with
module("SC.RangeObserver#destroy", {
  setup: function() {
    
    // create array with 5 SC.Object's in them
    source = [1,2,3,4,5].map(function(x) {
      return SC.Object.create({ item: x, foo: "bar" }) ;
    }, this); 

    indexes = SC.IndexSet.create(2,2); // select 2..3
    
    observer = SC.Object.create({
      
      callCount: 0, 
      
      rangeDidChange: function() { 
        this.callCount++;
      }
      
    });

    obj = SC.RangeObserver.create(source, indexes, observer, observer.rangeDidChange, "context", YES);
    
  }
});

test("returns receiver", function() {
  // for some reason doing equals() causes a stack exception (probably due
  // to a bug in jsDump)
  ok(obj.destroy() === obj, 'should return receiver');
});

// ..........................................................
// OBSERVING
// 

// NOTE: Since we are lazy about observing changes, we want to test both what
// happens if you destroy the observer before any changes have happend and 
// after changes have happened.

test("never observes changes if no changes happend", function() {
  obj.destroy();

  // change property on each object
  var len = source.length, idx;
  for(idx=0;idx<len;idx++) source[idx].set('foo', 'baz');

  // should not fire observer
  equals(observer.callCount, 0, 'range observer should not fire');
});

test("stops observes changes if changes happend before destroy", function() {
  var len = source.length, idx;

  // change property on each object
  for(idx=0;idx<len;idx++) source[idx].set('foo', 'baz');

  obj.destroy();

  // change property on each object again
  for(idx=0;idx<len;idx++) source[idx].set('foo', 'bar');

  // should fire observer only first time through
  equals(observer.callCount, 2, 'range observer should fire only first time through');
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/range_observer/create.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

var source, indexes, observer, obj ; // base array to work with
module("SC.RangeObserver#create", {
  setup: function() {
    
    // create array with 5 SC.Object's in them
    source = [1,2,3,4,5].map(function(x) {
      return SC.Object.create({ item: x, foo: "bar" }) ;
    }, this); 

    indexes = SC.IndexSet.create(2,2); // select 2..3
    
    observer = SC.Object.create({
      
      callCount: 0, 
      
      rangeDidChange: function() { 
        this.callCount++;
      }
      
    });

    obj = SC.RangeObserver.create(source, indexes, observer, observer.rangeDidChange, "context", YES);
    
  }
});

test("returns new instance", function() {
  ok(obj && obj.isRangeObserver, 'returns range observer');
});

test("sets up observing on properties for each object in range in index if isDeep", function() {
  var len = source.length, idx;
  for(idx=0;idx<len;idx++) {
    source[idx].set('foo', 'baz');
  }
  equals(observer.callCount, 2, 'range observer should fire twice');
});

test("does not observe object properties if isDeep is NO", function() {
  // remove unneeded observer
  obj.destroy();
  
  // use new observer
  obj = SC.RangeObserver.create(source, indexes, observer, observer.rangeDidChange, "context", NO);
  
  var len = source.length, idx;
  for(idx=0;idx<len;idx++) {
    source[idx].set('foo', 'baz');
  }
  equals(observer.callCount, 0, 'range observer should not fire');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/range_observer/objectPropertyDidChange.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

var source, indexes, observer, obj ; // base array to work with
module("SC.RangeObserver#objectPropertyDidChange", {
  setup: function() {
    
    // create array with 5 SC.Object's in them
    source = [1,2,3,4,5].map(function(x) {
      return SC.Object.create({ item: x, foo: "bar" }) ;
    }, this); 
    
    indexes = SC.IndexSet.create(2,2); // select 2..3
    
    observer = SC.Object.create({

      verify: NO ,
      
      callCount: 0, 
      
      object: NO,
      
      key: NO,

      indexes: NO,
      
      context: NO,
      
      setupVerify: function(object, key, indexes, context) {
        this.verify = YES ;  
        this.object = (object === undefined) ? NO : object ;
        this.key = (key === undefined) ? NO : key ;
        this.indexes = (indexes === undefined) ? NO :indexes ;
        this.context = (context === undefined) ? NO : context ;
        return this ;
      },
      
      // whenever this is called, verify proper params are passed
      changeObserver: function(inSource, inObject, inKey, inIndexes, inContext) { 
        this.callCount++;
        if (this.verify) {
          ok(source === inSource, 'source should match source array');
          
          if (this.object || this.object === null) {
            equals(inObject, this.object, 'passed object should match');  
          }

          if (this.key !== NO) {
            equals(inKey, this.key, 'passed key should match');
          }
          
          if (this.indexes) {
            ok(inIndexes && inIndexes.isIndexSet, 'passed indexes should be an index set (actual: %@)'.fmt(inIndexes));
            if (this.indexes.isIndexSet) {
              ok(this.indexes.isEqual(inIndexes), 'passed indexes should match %@ (actual: %@)'.fmt(this.indexes, inIndexes));
            }
          } else if (this.indexes === null) {
            equals(inIndexes, null, 'passed indexes should be null');
          }

          if (this.context !== NO) {
            equals(inContext, this.context, 'passed context should match');
          }

        }
      }
      
    });

  }
});

test("changing property on object that does not appear in range", function() {
  obj = SC.RangeObserver.create(source, indexes, observer, observer.changeObserver, null, YES);
  source[4].set('foo', 'baz');
  equals(observer.callCount, 0, 'should not invoke observer callback') ;
});

test("changing property on object that appears one time in range", function() {
  observer.setupVerify(source[2], 'foo', SC.IndexSet.create(2));
  
  obj = SC.RangeObserver.create(source, indexes, observer, observer.changeObserver, null, YES);
  source[2].set('foo', 'baz');
  equals(observer.callCount, 1, 'should not invoke observer callback') ;
}) ;

test("changing property on object that appears more than one time in range", function() {
  source[3] = source[2]; // copy item.  don't use KVO because we're testing it
  observer.setupVerify(source[2], 'foo', SC.IndexSet.create(2,2));
  
  obj = SC.RangeObserver.create(source, indexes, observer, observer.changeObserver, null, YES);
  source[2].set('foo', 'baz');
  equals(observer.callCount, 1, 'should not invoke observer callback') ;
});

test("changing all properties on object that apepars one time in range", function() {
  observer.setupVerify(source[2], '*', SC.IndexSet.create(2));
  
  obj = SC.RangeObserver.create(source, indexes, observer, observer.changeObserver, null, YES);
  source[2].allPropertiesDidChange();
  equals(observer.callCount, 1, 'should not invoke observer callback') ;
});

test("notifications with context", function() {
  observer.setupVerify(source[2], 'foo', SC.IndexSet.create(2), 'context');
  
  obj = SC.RangeObserver.create(source, indexes, observer, observer.changeObserver, 'context', YES);
  source[2].set('foo', 'baz');
  equals(observer.callCount, 1, 'should not invoke observer callback') ;
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/range_observer/rangeDidChange.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*global module test equals context ok same notest */

var source, indexes, observer, obj ; // base array to work with
module("SC.RangeObserver#rangeDidChange", {
  setup: function() {
    
    // create array with 5 SC.Object's in them
    source = [1,2,3,4,5].map(function(x) {
      return SC.Object.create({ item: x, foo: "bar" }) ;
    }, this); 

    indexes = SC.IndexSet.create(2,2); // select 2..3
    
    observer = SC.Object.create({

      verify: NO ,
      
      callCount: 0, 
      
      indexes: NO,
      
      // whenever this is called, verify proper params are passed
      changeObserver: function(inSource, inObject, inKey, inIndexes, inContext) { 
        this.callCount++;
        if (this.verify) {
          ok(source === inSource, 'source should match source array');
          ok(!inObject, 'object param should be null');
          equals(inKey, '[]', 'passed key should be brackets');
          if (this.indexes) {
            ok(this.indexes.isEqual(inIndexes), 'passed indexes should be %@.  actual: %@'.fmt(this.indexes, inIndexes));
          } else if (this.indexes === null) {
            equals(inIndexes, null, 'passed indexes should be null');
          }
          
          equals(inContext, 'context', 'should pass context');
        }
      }
      
    });

    obj = SC.RangeObserver.create(source, indexes, observer, observer.changeObserver, "context", YES);
    
  }
});

test("returns receiver", function() {
  ok(obj.rangeDidChange() === obj, 'should return receiver');
});

// ..........................................................
// CALLBACK
// 

test("invokes callback if no changes set is passed", function() {
  observer.verify = YES ;
  observer.indexes = null ;
  obj.rangeDidChange();
  equals(observer.callCount, 1, 'should invoke callback');
});

test("invokes callback if changes set is passed and it intersects with observed range", function() {
  observer.verify = YES ;
  observer.indexes = SC.IndexSet.create(1,2) ;
  obj.rangeDidChange(observer.indexes);
  equals(observer.callCount, 1, 'should invoke callback');
});

test("does NOT invoke callback if changes set is passed and it intersects with observed range", function() {
  obj.rangeDidChange(SC.IndexSet.create(4));
  equals(observer.callCount, 0, 'should NOT invoke callback');
});

// ..........................................................
// OBSERVER UPDATES
// 

test("if object in observed range changes, should stop observing old objects and start observing new objects - no previous changes", function() {
  
  var newObject = SC.Object.create({ item: 10, foo: "baz" });
  source[2] = newObject; // bypass KVO since we are testing it
  obj.rangeDidChange(SC.IndexSet.create(2));
  
  observer.callCount = 0 ;
  newObject.set('foo', 'bar');
  equals(observer.callCount, 1, 'should invoke observer when new object changes');
    
});

test("if object in observed range changes, should stop observing old objects and start observing new objects - previous changes", function() {
  
  source[2].set('foo', 'FOO2');
  equals(observer.callCount, 1, 'precond - should invoke observer on original object');
  
  var newObject = SC.Object.create({ item: 10, foo: "baz" });
  source[2] = newObject; // bypass KVO since we are testing it
  obj.rangeDidChange(SC.IndexSet.create(2));
  
  observer.callCount = 0 ;
  newObject.set('foo', 'bar');
  equals(observer.callCount, 1, 'should invoke observer when new object changes');
    
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/selection_set/remove.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

var set, array, array2, expected, expected2 ;
module("SC.SelectionSet#remove", {
  setup: function() {
    set = SC.SelectionSet.create();
    array = '0 1 2 3 4 5 6 7 8 9'.w();
    array2 = 'a b c d e f g h i k l m'.w();
    
    expected = SC.IndexSet.create(4,3);
    expected2 = SC.IndexSet.create(1);
    expected.source = array;
    expected2.source = array2;
  }
});

/* 
  validates that the selection set has the expected content.  pass index sets
  with sources set appropriately.  The order of the array is not important.
*/
function validate(set, expected, defaultSource) {
  var sources = set.get('sources'),
      len  = expected.length,
      idx, cur, actual ;
      
  equals(sources.length, expected.length, 'should have same number of sources (actual sources: %@)'.fmt(sources));  
  
  for(idx=0;idx<len;idx++) {
    cur = expected[idx];
    if (!cur.source) cur.source =defaultSource; 
    actual = set.indexSetForSource(cur.source, NO);
    ok(actual, 'should have indexSet for source: %@'.fmt(cur.source));
    equals(actual.source, cur.source, 'indexSet.source should match source');
    ok(actual.isEqual(cur), 'indexSet should match for source %@ (actual: %@ expected: %@)'.fmt(cur.source, actual, cur));
  }
}
// ..........................................................
// BASIC REMOVES
// 

test("Removed indexes for single source", function() {
  set.add(array, 4, 3);
  validate(set, [SC.IndexSet.create(4,3)], array); // precondition

  set.remove(array, 4, 1);
  validate(set, [SC.IndexSet.create(5,2)], array);
});

test("Removed multiple sources", function() {
  
  set.add(array, 4, 3).add(array2, 1);
  validate(set, [expected, expected2]); // precondition

  set.remove(array, 4,1).remove(array2, 1);
  expected.remove(4,1);
  validate(set, [expected]); // precondition
});

test("Remove IndexSet with source", function() {
  set.add(array, 4, 3);
  validate(set, [SC.IndexSet.create(4,3)], array); // precondition

  var s = SC.IndexSet.create(4,1);
  s.source = array;
  set.remove(s);
  validate(set, [SC.IndexSet.create(5,2)], array);
});

test("Adding another SelectionSet", function() {
  
  set.add(array, 4, 3).add(array2, 1);
  validate(set, [expected, expected2]); // precondition

  var x = SC.SelectionSet.create().add(array, 4,1).add(array2, 1);
  set.remove(x);
  
  expected.remove(4,1);
  validate(set, [SC.IndexSet.create(5,2)], array);
});


// ..........................................................
// SPECIAL CASES
// 

test("removing index set should also remove individually added objects", function() {
  var objToRemove = array[3]; // item from one array...
  var objToNotRemove = array2[3]; // item from array we won't remove..
  
  // add both objects.
  set.addObject(objToRemove).addObject(objToNotRemove);
  set.add(array, 4, 3);
  
  ok(set.contains(objToRemove), 'set should contain objToRemove');
  ok(set.contains(objToNotRemove), 'set should contain objToNotRemove');
  equals(set.get('length'), 5, 'set.length sould == two objects + index.length');
    
  // now remove from array set
  set.remove(array, 2, 4);  
  
  SC.stopIt = NO ;
  
  ok(!set.contains(objToRemove), 'set should NOT contain objToRemove');
  ok(set.contains(objToNotRemove), 'set should contain objToNotRemove');
  equals(set.get('length'), 2, 'set.length should == 1 object + index.length');
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/selection_set/add.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

var set, array, array2;
module("SC.SelectionSet#add", {
  setup: function() {
    set = SC.SelectionSet.create();
    array = '0 1 2 3 4 5 6 7 8 9'.w();
    array2 = 'a b c d e f g h i k l m'.w();
  }
});

/* 
  validates that the selection set has the expected content.  pass index sets
  with sources set appropriately.  The order of the array is not important.
*/
function validate(set, expected, defaultSource) {
  var sources = set.get('sources'),
      len  = expected.length,
      idx, cur, actual ;
      
  equals(sources.length, expected.length, 'should have same number of sources (actual sources: %@)'.fmt(sources));  
  
  for(idx=0;idx<len;idx++) {
    cur = expected[idx];
    if (!cur.source) cur.source =defaultSource; 
    actual = set.indexSetForSource(cur.source, NO);
    ok(actual, 'should have indexSet for source: %@'.fmt(cur.source));
    equals(actual.source, cur.source, 'indexSet.source should match source');
    ok(actual.isEqual(cur), 'indexSet should match for source %@ (actual: %@ expected: %@)'.fmt(cur.source, actual, cur));
  }
}

// ..........................................................
// BASIC ADDS
// 

test("Adding indexes for single source", function() {
  set.add(array, 4, 3);
  validate(set, [SC.IndexSet.create(4,3)], array);

  set.add(array, 1);
  validate(set, [SC.IndexSet.create(1).add(4,3)], array);
});

test("Adding multiple sources", function() {
  var expected = SC.IndexSet.create(4,3);
  var expected2 = SC.IndexSet.create(1);
  expected.source = array;
  expected2.source = array2;
  
  set.add(array, 4, 3);
  validate(set, [expected]);

  set.add(array2, 1);
  validate(set, [expected, expected2]);
});

test("Adding IndexSet with source", function() {
  var expected = SC.IndexSet.create(4,3);
  expected.source = array;
  
  set.add(expected);
  validate(set, [expected]);
});

test("Adding another SelectionSet", function() {
  var expected = SC.IndexSet.create(4,3);
  var expected2 = SC.IndexSet.create(1,5);
  expected.source = array;
  expected2.source = array2;
  
  set.add(array, 4, 3);
  validate(set, [expected]);

  var set2 = SC.SelectionSet.create().add(array2, 1, 5);
  validate(set2, [expected2]);
  
  set.add(set2);
  validate(set, [expected, expected2]);
});

test("Adding indexes with range object !!", function() {
  set.add(array, { start: 4, length: 3 });
  validate(set, [SC.IndexSet.create(4,3)], array);
});




})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/selection_set/indexSetForSource.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

var set, array, array2;
module("SC.SelectionSet#indexSetForSource", {
  setup: function() {
    set = SC.SelectionSet.create();
    array = '0 1 2 3 4 5 6 7 8 9'.w();
    array2 = 'a b c d e f g h i k l m'.w();
  }
});

test("empty selection set", function() {
  equals(set.indexSetForSource(array), null, 'should return null for source not in set');
  equals(set.indexSetForSource(array2), null, 'should return null for source not in set (2)');
});

test("selection set if index range is added", function() {
  var ret;
  
  set.add(array, 3,4);
  ret = set.indexSetForSource(array);
  ok(ret, 'should return an index set for the array');
  same(ret, SC.IndexSet.create(3,4), 'should be index set that was added');  
  
  set.remove(array,3,1);
  ret = set.indexSetForSource(array);
  same(ret, SC.IndexSet.create(4,3), 'should return new index set when membership changes');
  
  set.add(array,10,1);
  ret = set.indexSetForSource(array);
  same(ret, SC.IndexSet.create(4,3).add(10,1), 'should return combined index set when multiple items are added');
});

test("selection set if objects in index set are added", function() {
  var ret ;
  set.addObjects(["0", 'a']);
  
  ret = set.indexSetForSource(array);
  same(ret, SC.IndexSet.create(0,1), 'should return index set with objects found in set interpolated');  

  ret = set.indexSetForSource(array2);
  same(ret, SC.IndexSet.create(0,1), 'should return index set with objects found in set interpolated (2)');
  
  set.removeObject("0");
  ret = set.indexSetForSource(array);
  equals(ret, null, 'should return null when matching objects are removed');  

  ret = set.indexSetForSource(array2);
  same(ret, SC.IndexSet.create(0,1), 'removing other objects should not effect');

});


test("selection set if objects and ranged are added", function() {
  var ret ;
  set.add(array, 4,3).addObjects(["0", 'a']);
  
  ret = set.indexSetForSource(array);
  same(ret, SC.IndexSet.create(0,1).add(4,3), 'should return index set with objects found in set interpolated');  

  ret = set.indexSetForSource(array2);
  same(ret, SC.IndexSet.create(0,1), 'should return index set with objects found in set interpolated (2)');
  
  set.removeObject("0");
  ret = set.indexSetForSource(array);
  same(ret, SC.IndexSet.create(4,3), 'should return just range when objects are removed');  

  ret = set.indexSetForSource(array2);
  same(ret, SC.IndexSet.create(0,1), 'removing other objects should not effect');

});


// ..........................................................
// SPECIAL CASES
// 

test("add and remove source", function() {
  set.add(array, 3,4).remove(array, 3,4);
  equals(set.indexSetForSource(array), null, 'should return null for source not in set');
});

test("looking up indexSet for source when objects are added should recache when source content changes", function() {
  var obj = array.objectAt(0), ret;
  
  set = SC.SelectionSet.create().addObject(obj);
  ret = set.indexSetForSource(array);
  same(ret, SC.IndexSet.create(0), 'should return index set with item at 0');

  array.removeObject(obj).pushObject(obj); // move obj to end.
  ret = set.indexSetForSource(array) ;
  same(ret, SC.IndexSet.create(array.indexOf(obj)), 'should return index set with item at end');
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/selection_set/isEqual.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

// TODO: Make these unit tests more complete.

var set1, set2, content;
module("SC.SelectionSet.isEqual", {
  setup: function() {
    content = '1 2 3 4 5 6 7 8 9 0'.w();
    set1 = SC.SelectionSet.create();
    set2 = SC.SelectionSet.create();
  }
});

test("set.isEqual(same instance)", function() {
  ok(set1.isEqual(set1), 'same instance should return YES');
});

test("set.isEqual(null)", function() {
  ok(!set1.isEqual(null), 'null should return NO');
});


test("set1.isEqual(set2)", function() {
  ok(set1.isEqual(set2), 'same content should return YES');
  
  set1.add(content, 4,4);
  set2.add(content, 4,4);
  ok(set1.isEqual(set2), 'same content should return YES');

  set1.remove(content, 6);
  set2.remove(content, 6);
  ok(set1.isEqual(set2), 'same content should return YES');

  set1.remove(content, 4,4);
  set2.remove(content, 4,4);
  ok(set1.isEqual(set2), 'same content should return YES');
  
});

test("multiple content objects", function() {
  var content2 = "1 2 3 4 5".w();
  set1.add(content, 4,4).add(content2, 3);
  ok(!set1.isEqual(set2), 'should not be same when set2 is empty');

  set2.add(content2, 3);
  ok(!set1.isEqual(set2), 'should not be same when set2 has only one content');

  set2.add(content,4,4);
  ok(set1.isEqual(set2), 'should not be same when set2 has both content');
  
});

test("set1.isEqual(set2) after set2 is filled and emptied", function() {
  set2.add(content,4,4).remove(content,4,4);
  ok(set1.isEqual(set2), 'same content should return YES');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/selection_set/copy.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

module("SC.SelectionSet.copy");

test("basic copy", function() {
  var content = "1 2 3 4 5 6 7 8 9".w(),
      set     = SC.SelectionSet.create().add(content,4,4).remove(content,6),
      copy    = set.copy();
  
  equals(set.get('length'), 3, 'precond - original set should have length');
  equals(copy.get('length'), 3, 'copy should have same length');
  same(copy, set, 'copy should be the same as original set');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/object/bindings.js"; 
}
(function() {
// ========================================================================
// SC.Object bindings Tests
// ========================================================================
/*globals module test ok isObj equals expects */

var testObject, fromObject, extraObject, TestObject;

module("bind() method", {
  
  setup: function() {
    testObject = SC.Object.create({
      foo: "bar",
      bar: "foo",
      extraObject: null 
    });
    
    fromObject = SC.Object.create({
      bar: "foo",
      extraObject: null 
    }) ;
    
    extraObject = SC.Object.create({
      foo: "extraObjectValue"
    }) ;
    
    TestNamespace = {
      fromObject: fromObject,
      testObject: testObject
    } ;
  },
  
  teardown: function() { 
    delete testObject ; 
    delete fromObject ;
    delete extraObject ;
  //  delete TestNamespace ;
  }
  
});
  
test("bind(TestNamespace.fromObject.bar) should follow absolute path", function() {
  // create binding
  testObject.bind("foo", "TestNamespace.fromObject.bar") ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", "changedValue") ;
  
  // support new-style bindings if available
  SC.Binding.flushPendingChanges();
  equals("changedValue", testObject.get("foo"), "testObject.foo");
});
  
test("bind(.bar) should bind to relative path", function() {
  // create binding
  testObject.bind("foo", ".bar") ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  testObject.set("bar", "changedValue") ;
  
  SC.Binding.flushPendingChanges();
  equals("changedValue", testObject.get("foo"), "testObject.foo");
});

test("SC.Binding.bool(TestNamespace.fromObject.bar)) should create binding with bool transform", function() {
  // create binding
  testObject.bind("foo", SC.Binding.bool("TestNamespace.fromObject.bar")) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", 1) ;
  
  SC.Binding.flushPendingChanges();
  equals(YES, testObject.get("foo"), "testObject.foo == YES");
  
  fromObject.set("bar", 0) ;
  
  SC.Binding.flushPendingChanges();
  equals(NO, testObject.get("foo"), "testObject.foo == NO");
});

test("bind(TestNamespace.fromObject*extraObject.foo) should create chained binding", function() {
  testObject.bind("foo", "TestNamespace.fromObject*extraObject.foo");
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  fromObject.set("extraObject", extraObject) ;
  
  SC.Binding.flushPendingChanges();
  equals("extraObjectValue", testObject.get("foo"), "testObject.foo") ;
});

test("bind(*extraObject.foo) should create locally chained binding", function() {
  testObject.bind("foo", "*extraObject.foo");
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  testObject.set("extraObject", extraObject) ;
  
  SC.Binding.flushPendingChanges();
  equals("extraObjectValue", testObject.get("foo"), "testObject.foo") ;
});


module("fooBinding method", {
  
  setup: function() {
    TestObject = SC.Object.extend({
      foo: "bar",
      bar: "foo",
      extraObject: null 
    });
    
    fromObject = SC.Object.create({
      bar: "foo",
      extraObject: null 
    }) ;
    
    extraObject = SC.Object.create({
      foo: "extraObjectValue"
    }) ;
        
    TestNamespace = {
      fromObject: fromObject,
      testObject: TestObject
    } ;
  },
  
  teardown: function() { 
    delete TestObject ;
    delete fromObject ;
    delete extraObject ;
  //  delete TestNamespace ;
  }
  
});

test("fooBinding: TestNamespace.fromObject.bar should follow absolute path", function() {
  // create binding
  testObject = TestObject.create({
    fooBinding: "TestNamespace.fromObject.bar"
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", "changedValue") ;
  
  SC.Binding.flushPendingChanges();
  equals("changedValue", testObject.get("foo"), "testObject.foo");
});

test("fooBinding: .bar should bind to relative path", function() {
  
  testObject = TestObject.create({
    fooBinding: ".bar"
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  testObject.set("bar", "changedValue") ;
  
  SC.Binding.flushPendingChanges();
  equals("changedValue", testObject.get("foo"), "testObject.foo");
});

test("fooBinding: SC.Binding.bool(TestNamespace.fromObject.bar should create binding with bool transform", function() {
  
  testObject = TestObject.create({
    fooBinding: SC.Binding.bool("TestNamespace.fromObject.bar") 
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", 1) ;
  
  SC.Binding.flushPendingChanges();
  equals(YES, testObject.get("foo"), "testObject.foo == YES");
  
  fromObject.set("bar", 0) ;
  
  SC.Binding.flushPendingChanges();
  equals(NO, testObject.get("foo"), "testObject.foo == NO");
});

test("fooBinding: TestNamespace.fromObject*extraObject.foo should create chained binding", function() {
  
  testObject = TestObject.create({
    fooBinding: "TestNamespace.fromObject*extraObject.foo" 
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  fromObject.set("extraObject", extraObject) ;
  
  SC.Binding.flushPendingChanges();
  equals("extraObjectValue", testObject.get("foo"), "testObject.foo") ;
});

test("fooBinding: *extraObject.foo should create locally chained binding", function() {
  
  testObject = TestObject.create({
    fooBinding: "*extraObject.foo" 
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  testObject.set("extraObject", extraObject) ;
  
  SC.Binding.flushPendingChanges();
  equals("extraObjectValue", testObject.get("foo"), "testObject.foo") ;
});

module("fooBindingDefault: SC.Binding.Bool (old style)", {
  
  setup: function() {
    TestObject = SC.Object.extend({
      foo: "bar",
      fooBindingDefault: SC.Binding.bool(),
      bar: "foo",
      extraObject: null 
    });
    
    fromObject = SC.Object.create({
      bar: "foo",
      extraObject: null 
    }) ;
    
    TestNamespace = {
      fromObject: fromObject,
      testObject: TestObject
    } ;
  },
  
  teardown: function() { 
    delete TestObject ;
    delete fromObject ;
 //   delete TestNamespace ;
  }
  
});

test("fooBinding: TestNamespace.fromObject.bar should have bool binding", function() {
  // create binding
  testObject = TestObject.create({
    fooBinding: "TestNamespace.fromObject.bar"
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", 1) ;
  
  SC.Binding.flushPendingChanges();
  equals(YES, testObject.get("foo"), "testObject.foo == YES");
  
  fromObject.set("bar", 0) ;
  
  SC.Binding.flushPendingChanges();
  equals(NO, testObject.get("foo"), "testObject.foo == NO");
});

test("fooBinding: SC.Binding.not(TestNamespace.fromObject.bar should override default", function() {
  
  testObject = TestObject.create({
    fooBinding: SC.Binding.not("TestNamespace.fromObject.bar") 
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", 1) ;
  
  SC.Binding.flushPendingChanges();
  equals(NO, testObject.get("foo"), "testObject.foo == NO");
  
  fromObject.set("bar", 0) ;
  
  SC.Binding.flushPendingChanges();
  equals(YES, testObject.get("foo"), "testObject.foo == YES");
});

module("fooBindingDefault: SC.Binding.bool() (new style)", {
  
  setup: function() {
    TestObject = SC.Object.extend({
      foo: "bar",
      fooBindingDefault: SC.Binding.bool(),
      bar: "foo",
      extraObject: null 
    });
    
    fromObject = SC.Object.create({
      bar: "foo",
      extraObject: null 
    }) ;
    
    TestNamespace = {
      fromObject: fromObject,
      testObject: testObject
    } ;
  },
  
  teardown: function() { 
    delete TestObject ;
    delete fromObject ;
   // delete TestNamespace ;
  }
  
});

test("fooBinding: TestNamespace.fromObject.bar should have bool binding", function() {
  // create binding
  testObject = TestObject.create({
    fooBinding: "TestNamespace.fromObject.bar"
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", 1) ;
  
  SC.Binding.flushPendingChanges();
  equals(YES, testObject.get("foo"), "testObject.foo == YES");
  
  fromObject.set("bar", 0) ;
  
  SC.Binding.flushPendingChanges();
  equals(NO, testObject.get("foo"), "testObject.foo == NO");
});

test("fooBinding: SC.Binding.not(TestNamespace.fromObject.bar should override default", function() {
  
  testObject = TestObject.create({
    fooBinding: SC.Binding.not("TestNamespace.fromObject.bar") 
  }) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  fromObject.set("bar", 1) ;
  
  SC.Binding.flushPendingChanges();
  equals(NO, testObject.get("foo"), "testObject.foo == NO");
  
  fromObject.set("bar", 0) ;
  
  SC.Binding.flushPendingChanges();
  equals(YES, testObject.get("foo"), "testObject.foo == YES");
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/object/base.js"; 
}
(function() {
// ========================================================================
// SC.Object Base Tests
// ========================================================================
/*globals module test ok isObj equals expects same plan */

var obj, obj1, don, don1 ; // global variables

module("A new SC.Object instance", {
  
  setup: function() {
    obj = SC.Object.create({
      foo: "bar",
      total: 12345,
      aMethodThatExists: function() {},
      aMethodThatReturnsTrue: function() { return true; },
      aMethodThatReturnsFoobar: function() { return "Foobar"; },
      aMethodThatReturnsFalse: function() { return NO; }
    });
  },
  
  teardown: function() {
    obj = undefined ;
  }
  
});

test("Should identify it's methods using the 'respondsTo' method", function() {
  equals(obj.respondsTo('aMethodThatExists'), true) ;
  equals(obj.respondsTo('aMethodThatDoesNotExist'), false) ;
});

test("Should return false when asked to perform a method it does not have", function() {
  equals(obj.tryToPerform('aMethodThatDoesNotExist'), false) ;
});

test("Should pass back the return YES if method returned YES, NO if method not implemented or returned NO", function() {
  equals(obj.tryToPerform('aMethodThatReturnsTrue'), YES, 'method that returns YES') ;
  equals(obj.tryToPerform('aMethodThatReturnsFoobar'), YES, 'method that returns non-NO') ;
  equals(obj.tryToPerform('aMethodThatReturnsFalse'), NO, 'method that returns NO') ;
  equals(obj.tryToPerform('imaginaryMethod'), NO, 'method that is not implemented') ;
});

test("Should return it's properties when requested using SC.Object#get", function() {
  equals(obj.get('foo'), 'bar') ;
  equals(obj.get('total'), 12345) ;
});

test("Should allow changing of those properties by calling SC.Object#set", function() {
  equals(obj.get('foo'), 'bar') ;
  equals(obj.get('total'), 12345) ;
  
  obj.set( 'foo', 'Chunky Bacon' ) ;
  obj.set( 'total', 12 ) ;
  
  equals(obj.get('foo'), 'Chunky Bacon') ;
  equals(obj.get('total'), 12) ;
});

test("Should only advertise changes once per request to SC.Object#didChangeFor", function() {
  obj.set( 'foo', 'Chunky Bacon' );
  equals(obj.didChangeFor( this, 'foo' ), true) ;
  equals(obj.didChangeFor( this, 'foo' ), false) ;
});

test("Should advertise changes once per request to SC.Object#didChangeFor when setting property to NULL", function() {
  obj.set( 'foo', null );
  equals(obj.didChangeFor( this, 'foo' ), true) ;
  equals(obj.didChangeFor( this, 'foo' ), false) ;
});

test("When the object is destroyed the 'isDestroyed' status should change accordingly", function() {
	equals(obj.get('isDestroyed'), NO);
	obj.destroy();
	equals(obj.get('isDestroyed'), YES);
});


module("SC.Object instance extended", {  
  setup: function() {
    obj = SC.Object.extend();
	obj1 = obj.create();
	don = SC.Object.extend();
	don1 = don.create();
  },
  
  teardown: function() {
    obj = undefined ;
    obj1 = undefined ;
    don = undefined ;
    don1 = undefined ;
  }
  
});

test("Checking the instance of method for an object", function() {
	equals(obj1.instanceOf(obj), YES);
	equals(obj1.instanceOf(don), NO);
});

test("Checking the kind of method for an object", function() {
	equals(obj1.kindOf(obj), YES);
	equals(obj1.kindOf(don), NO);
	
	equals(SC.kindOf(obj1, obj), YES);
	equals(SC.kindOf(obj1, don), NO);
	equals(SC.kindOf(null, obj1), NO);
});


module("SC.Object superclass and subclasses", {  
  setup: function() {
    obj = SC.Object.extend ({
	  method1: function() {
		return "hello";
	  }
	});
	obj1 = obj.extend();
	don = obj1.create ({
	  method2: function() {
		  return this.superclass();
		}
	});
  },

  teardown: function() {
	obj = undefined ;
    obj1 = undefined ;
    don = undefined ;
  }
});

test("Checking the superclass method for an existing function", function() {
	equals(don.method2().method1(), "hello");
});

test("Checking the subclassOf function on an object and its subclass", function(){
	equals(obj1.subclassOf(obj), YES);
	equals(obj.subclassOf(obj1), NO);
});

test("subclasses should contain defined subclasses", function() {
  ok(obj.subclasses.contains(obj1), 'obj.subclasses should contain obj1');
  
  equals(obj1.subclasses.get('length'),0,'obj1.subclasses should be empty');
  
  var kls2 = obj1.extend();
  ok(obj1.subclasses.contains(kls2), 'obj1.subclasses should contain kls2');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/error.js"; 
}
(function() {
// ========================================================================
// SC.Error Base Tests
// ========================================================================
/*globals module test ok isObj equals expects */

module("SC.ERROR");

test("SC.Error.desc creates an error instance with description,label and code", function() {
  var c = SC.Error.desc('This is an error instance','Error Instance', "FOO", 99999);
  equals(SC.T_ERROR,SC.typeOf(c),'Error instance');
  equals('This is an error instance',c.message,'Description');
  equals('Error Instance',c.label,'Label');
  equals(c.get('errorValue'), "FOO", 'error value should be set');
  equals(99999,c.code,'Code');
});

test("SC.$error creates an error instance with description,label and code",function(){
  var d = SC.$error('This is a new error instance','New Error Instance', "FOO", 99999);
  equals(SC.T_ERROR,SC.typeOf(d),'New Error instance');
  equals('This is a new error instance',d.message,'Description');
  equals('New Error Instance',d.label,'Label');
  equals(d.get('errorValue'), "FOO", 'error value should be set');
  equals(99999,d.code,'Code');
});

test("SC.$ok should return YES if the passed value is an error object or false", function() {
  ok(SC.$ok(true), '$ok(true) should be YES');
  ok(!SC.$ok(false), '$ok(false) should be NO');
  ok(SC.$ok(null), '$ok(null) should be YES');
  ok(SC.$ok(undefined), '$ok(undefined) should be YES');
  ok(SC.$ok("foo"), '$ok(foo) should be YES');
  ok(!SC.$ok(SC.$error("foo")), '$ok(SC.Error) should be NO');

  ok(!SC.$ok(new SC.Error()), '$ok(Error) should be NO');
  ok(!SC.$ok(SC.Object.create({ isError: YES })), '$ok({ isError: YES }) should be NO');
});

test("SC.$val should return the error value if it has one", function() {
  equals(SC.val(true), true, 'val(true) should be true');
  equals(SC.val(false), false, 'val(false) should be false');
  equals(SC.val(null), null, 'val(null) should be YES');
  equals(SC.val(undefined), undefined, '$ok(undefined) should be YES');
  equals(SC.val("foo"), "foo", 'val(foo) should be YES');
  equals(SC.val(SC.$error("foo", "FOO", "BAZ")), "BAZ", 'val(SC.Error) should be BAZ');
  equals(SC.val(SC.$error("foo", "FOO")), undefined, 'val(SC.Error) should be undefined');
  equals(SC.val(new SC.Error()), null, 'val(Error) should be null');
  equals(SC.val(SC.Object.create({ isError: YES, errorValue: "BAR" })), "BAR", 'val({ isError: YES, errorValue: BAR }) should be BAR');
});

test("errorObject property should return the error itself", function() {
  var er = SC.$error("foo");
  equals(er.get('errorObject'), er, 'errorObject should return receiver');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/binding.js"; 
}
(function() {
// ========================================================================
// SC.Binding Tests
// ========================================================================
/*globals module test ok isObj equals expects */

var fromObject, toObject, binding, Bon1, bon2 ; // global variables

module("basic object binding", {
  
  setup: function() {
    fromObject = SC.Object.create({ value: 'start' }) ;
    toObject = SC.Object.create({ value: 'end' }) ;
    binding = SC.Binding.from("value", fromObject).to("value", toObject).connect() ;
    SC.Binding.flushPendingChanges() ; // actually sets up up the connection
  }
});
  
test("binding is connected", function() {
  equals(binding.isConnected, YES, "binding.isConnected") ;
});

test("binding has actually been setup", function() {
  equals(binding._connectionPending, NO, "binding._connectionPending") ;
});

test("binding should have synced on connect", function() {
  equals(toObject.get("value"), "start", "toObject.value should match fromObject.value");
});

test("changing fromObject should mark binding as dirty", function() {
  fromObject.set("value", "change") ;
  equals(binding._changePending, YES) ;
});

test("fromObject change should propogate to toObject only after flush", function() {
  fromObject.set("value", "change") ;
  equals(toObject.get("value"), "start") ;
  SC.Binding.flushPendingChanges() ;
  equals(toObject.get("value"), "change") ;    
});

test("changing toObject should mark binding as dirty", function() {
  toObject.set("value", "change") ;
  equals(binding._changePending, YES) ;
});

test("toObject change should propogate to fromObject only after flush", function() {
  toObject.set("value", "change") ;
  equals(fromObject.get("value"), "start") ;
  SC.Binding.flushPendingChanges() ;
  equals(fromObject.get("value"), "change") ;    
});

test("suspended observing during bindings", function() {

  // setup special binding
  fromObject = SC.Object.create({
    value1: 'value1',
    value2: 'value2'
  });
  
  toObject = SC.Object.create({
    value1: 'value1',
    value2: 'value2',
    
    callCount: 0,
    
    observer: function() {
      equals(this.get('value1'), 'CHANGED', 'value1 when observer fires');
      equals(this.get('value2'), 'CHANGED', 'value2 when observer fires');
      this.callCount++;
    }.observes('value1', 'value2')
  });
  
  toObject.bind('value1', fromObject, 'value1');
  toObject.bind('value2', fromObject, 'value2');

  // change both value1 + value2, then  flush bindings.  observer should only
  // fire after bindings are done flushing.
  fromObject.set('value1', 'CHANGED').set('value2', 'CHANGED');
  SC.Binding.flushPendingChanges();
  
  equals(toObject.callCount, 2, 'should call observer twice');
});

module("one way binding", {
  
  setup: function() {
    fromObject = SC.Object.create({ value: 'start' }) ;
    toObject = SC.Object.create({ value: 'end' }) ;
    binding = SC.Binding.from("value", fromObject).to("value", toObject).oneWay().connect() ;
    SC.Binding.flushPendingChanges() ; // actually sets up up the connection
  }
  
});
  
test("changing fromObject should mark binding as dirty", function() {
  fromObject.set("value", "change") ;
  equals(binding._changePending, YES) ;
});

test("fromObject change should propogate after flush", function() {
  fromObject.set("value", "change") ;
  equals(toObject.get("value"), "start") ;
  SC.Binding.flushPendingChanges() ;
  equals(toObject.get("value"), "change") ;    
});

test("changing toObject should not make binding dirty", function() {
  toObject.set("value", "change") ;
  equals(binding._changePending, NO) ;
});

test("toObject change should NOT propogate", function() {
  toObject.set("value", "change") ;
  equals(fromObject.get("value"), "start") ;
  SC.Binding.flushPendingChanges() ;
  equals(fromObject.get("value"), "start") ;    
});

var first, second, third, binding1, binding2 ; // global variables

module("chained binding", {
  
  setup: function() {
    first = SC.Object.create({ output: 'first' }) ;
    
    second = SC.Object.create({ 
      input: 'second',
      output: 'second',
      
      inputDidChange: function() {
        this.set("output", this.get("input")) ;
      }.observes("input")  
    }) ;
    
    third = SC.Object.create({ input: "third" }) ;
    
    binding1 = SC.Binding.from("output", first).to("input", second).connect() ;
    binding2 = SC.Binding.from("output", second).to("input", third).connect() ;
    SC.Binding.flushPendingChanges() ; // actually sets up up the connection
  }
  
});

test("changing first output should propograte to third after flush", function() {
  first.set("output", "change") ;
  equals("change", first.get("output"), "first.output") ;
  ok("change" !== third.get("input"), "third.input") ;
  
  var didChange = YES;
  while(didChange) didChange = SC.Binding.flushPendingChanges() ;
  
  // bindings should not have bending changes
  equals(binding1._changePending, NO, "binding1._changePending") ;
  equals(binding2._changePending, NO, "binding2._changePending") ;
  
  equals("change", first.get("output"), "first.output") ;
  equals("change", second.get("input"), "second.input") ;
  equals("change", second.get("output"), "second.output") ;
  equals("change", third.get("input"), "third.input") ;
});

module("Custom Binding", {
  
  setup: function() {
	Bon1 = SC.Object.extend({
		value1: "hi",
		value2: 83,
		array1: []
	});
	
	bon2 = SC.Object.create({
		val1: "hello",
		val2: 25,
		arr: [1,2,3,4]
	});
	
	TestNamespace = {
      bon2: bon2,
      Bon1: Bon1
    } ;
  },
  
  teardown: function() { 
    delete Bon1 ;
    delete bon2 ;
	//delete TestNamespace;
  }
});

test("Binding value1 such that it will recieve only single values", function() {
	var bon1 = Bon1.create({
		value1Binding: SC.Binding.single("TestNamespace.bon2.val1"),
		array1Binding: SC.Binding.single("TestNamespace.bon2.arr")
	});
	SC.Binding.flushPendingChanges();
	var a = [23,31,12,21];
	bon2.set("arr", a);
	bon2.set("val1","changed");
	SC.Binding.flushPendingChanges();
	equals(bon2.get("val1"),bon1.get("value1"));
	equals("@@MULT@@",bon1.get("array1"));
	bon1.destroy();
});

test("Single binding using notEmpty function.", function() {
	var bond = Bon1.create ({
	  array1Binding: SC.Binding.single("TestNamespace.bon2.arr").notEmpty(null,'(EMPTY)')
	});
	SC.Binding.flushPendingChanges();
	bon2.set("arr", []);
	SC.Binding.flushPendingChanges();
	equals("(EMPTY)",bond.get("array1"));
});

test("Binding with transforms, function to check the type of value", function() {
	var jon = Bon1.create({
		value1Binding: SC.Binding.transform(function(val1) {
			return (SC.typeOf(val1) == SC.T_STRING)? val1 : "";
		}).from("TestNamespace.bon2.val1")
	});
	SC.Binding.flushPendingChanges();
	bon2.set("val1","changed");
	SC.Binding.flushPendingChanges();
	equals(jon.get("value1"), bon2.get("val1"));
});

test("two bindings to the same value should sync in the order they are initialized", function() {

  SC.LOG_BINDINGS = YES;

  SC.RunLoop.begin();

  window.a = SC.Object.create({ 
    foo: "bar" 
  });
  
  var a = window.a;
  
  window.b = SC.Object.create({ 
    foo: "baz",
    fooBinding: "a.foo",
    
    C: SC.Object.extend({
      foo: "bee",
      fooBinding: "*owner.foo"
    }),
    
    init: function() {
      arguments.callee.base.apply(this,arguments);
      this.set('c', this.C.create({ owner: this }));
    }
    
  });
  
  var b = window.b;

  SC.LOG_BINDINGS = YES;
    
  SC.RunLoop.end();
  
  equals(a.get('foo'), "bar", 'a.foo should not change');
  equals(b.get('foo'), "bar", 'a.foo should propogate up to b.foo');
  equals(b.c.get('foo'), "bar", 'a.foo should propogate up to b.c.foo');
  
  window.a = window.b = null ;
  
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/system/run_loop.js"; 
}
(function() {
module("System:run_loop() - chained binding", {
  setup: function() {
    first = SC.Object.create({ 
		output: 'first' 
	}) ;
    
	second = SC.Object.create({ 
      input: 'second',
      output: 'second',
      
      inputDidChange: function() {
        this.set("output", this.get("input")) ;
      }.observes("input") 

    }) ;
    
    third = SC.Object.create({ 
		input: "third" 
	}) ;
  }
});

test("Should propograte bindings after the RunLoop completes (using SC.RunLoop)", function() {
	SC.RunLoop.begin();
		//Binding of output of first object to input of second object
  		binding1 = SC.Binding.from("output", first).to("input", second).connect() ;
    	
		//Binding of output of second object to input of third object
		binding2 = SC.Binding.from("output", second).to("input", third).connect() ;
		
		SC.Binding.flushPendingChanges() ; // actually sets up the connection
		
		//Based on the above binding if you change the output of first object it should
		//change the all the variable of first,second and third object
		first.set("output", "change") ;
		
		//Changes the output of the first object
		equals(first.get("output"), "change") ;
		
		//since binding has not taken into effect the value still remains as change.
		equals(second.get("output"), "first") ;
	SC.RunLoop.end(); // allows bindings to trigger...
	
	//Value of the output variable changed to 'change'
	equals(first.get("output"), "change") ;
	
	//Since binding triggered after the end loop the value changed to 'change'.
	equals(second.get("output"), "change") ;
});

test("Should propograte bindings after the RunLoop completes (using SC.beginRunLoop)", function() {
	SC.beginRunLoop;
		//Binding of output of first object to input of second object
  		binding1 = SC.Binding.from("output", first).to("input", second).connect() ;
    	
		//Binding of output of second object to input of third object
		binding2 = SC.Binding.from("output", second).to("input", third).connect() ;
		
		SC.Binding.flushPendingChanges() ; // actually sets up the connection
		
		//Based on the above binding if you change the output of first object it should
		//change the all the variable of first,second and third object
		first.set("output", "change") ;
		
		//Changes the output of the first object
		equals(first.get("output"), "change") ;
		
		//since binding has not taken into effect the value still remains as change.
		equals(second.get("output"), "first") ;
	SC.endRunLoop; // allows bindings to trigger...
	SC.Binding.flushPendingChanges() ; // actually sets up the connection
	
	//Value of the output variable changed to 'change'
	equals(first.get("output"), "change") ;
	
	//Since binding triggered after the end loop the value changed to 'change'.
	equals(second.get("output"), "change") ;
});

test("Should propograte bindings after the RunLoop completes (checking invokeOnce() function)", function() {
	SC.RunLoop.begin();
		//Binding of output of first object to input of second object
  		binding1 = SC.Binding.from("output", first).to("input", second).connect() ;
    	
		//Binding of output of second object to input of third object
		binding2 = SC.Binding.from("output", second).to("input", third).connect() ;
		
		SC.Binding.flushPendingChanges() ; // actually sets up the connection
		
		//Based on the above binding if you change the output of first object it should
		//change the all the variable of first,second and third object
		first.set("output", "change") ;
		
		//Changes the output of the first object
		equals(first.get("output"), "change") ;
		
		//since binding has not taken into effect the value still remains as change.
		equals(second.get("output"), "first") ;
		
		// Call the invokeOnce function to set the function which needs to be called once
		second.invokeOnce('second','inputDidChange');
		
	SC.RunLoop.end(); // allows bindings to trigger...
	
	//Value of the output variable changed to 'change'
	equals(first.get("output"), "change") ;
	
	//Since binding triggered after the end loop the value changed to 'change'.
	equals(second.get("output"), "change") ;
	
	//Set the output for the first so that the 'inputDidChange' function in the second object is called again
	first.set("output", "againChanged") ;
	
	//Value of the output variable changed to 'change'
	equals(first.get("output"), "againChanged") ;
	
	//Since the invoker function is called only once the value of output did not change.
	equals(second.get("output"), "change") ;
	
}); 
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/clone.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore Costello - Property Observing Library
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*globals module test ok equals expects object same */

var object ;

module("Cloned Objects", {
  setup: function() {
    
	object = SC.Object.create({
	
	  name:'Cloned Object',
	  value:'value1',
	 
	  clone: function(object) {
	    var ret = object ;
	    switch (SC.typeOf(object)) {
	  
	  	 case SC.T_ARRAY:
	        ret = object.slice() ;
	    	break ;

	     case SC.T_OBJECT:
	        ret = {} ;
	        for(var key in object) ret[key] = object[key] ;
	    }

	    return ret ;
	  }
	});
  }
});


test("should return a cloned object", function() {
	var objectA = [1,2,3,4,5] ;
	var objectB = "SproutCore" ;
	var objectC = SC.hashFor(objectA);	
	var objectE = 100;
	var a = SC.clone(objectA);
	var b = SC.clone(objectA);
	
  	equals(SC.clone(objectB), SC.clone(objectB)) ;
	equals(SC.clone(objectC), SC.clone(objectC)) ;
	equals(SC.clone(objectE), SC.clone(objectE)) ;
	same(a, b);
});

test("should return cloned object when the object is null", function() {
	var objectD = null;
  	equals(SC.clone(objectD), SC.clone(objectD)) ;
});

test("should return a cloned array ", function() {
	var arrayA  = ['value1','value2'] ;
	var resultArray = object.clone(arrayA);
    equals(resultArray[0], arrayA[0], 'check first array item');
    equals(resultArray[1], arrayA[1], 'check first array item');
		
});

test("should use copy() if isCopyable", function() {
  var obj = SC.Object.create(SC.Copyable, {
    isCopy: NO,
    
    copy: function() {
      return SC.Object.create(SC.Copyable, { isCopy: YES });
    }
    
  });
  
  var copy = SC.clone(obj);
  ok(!!copy, 'clone should return a copy');
  equals(copy.isCopy, YES, 'copy.isCopy should be YES');
});

test("SC.copy should be an alias for SC.clone", function() {
  equals(SC.copy, SC.clone, 'SC.copy should equal SC.clone');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/keys.js"; 
}
(function() {
// ========================================================================
// SC.keys Tests
// ========================================================================
/*globals module test */

module("Fetch Keys ");

test("should get a key array for a specified object ",function(){
	var object1 = {};

	object1.names = "Rahul";
	object1.age = "23";
	object1.place = "Mangalore";

	var object2 = [];
	object2 = SC.keys(object1);
	same(object2,['names','age','place']);
});



})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/console.js"; 
}
(function() {
// ========================================================================
// SC.guidFor Tests
// ========================================================================
/*globals module test ok isObj equals expects */


module("Console object");

test("The console object should be defined for all browsers and work if supported", function() {
  ok((console!==undefined), "console should not be undefined");
  console.info("Console.info is working");
  console.log("Console.log is working");
  console.warn("Console.warn is working");
  console.error("Console.error is working");
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/beget.js"; 
}
(function() {
// ========================================================================
// SC.guidFor Tests
// ========================================================================
/*globals module test ok isObj equals expects */

var objectA, objectB , arrayA, stringA; // global variables

module("Beget function Module", {
setup: function() {
    objectA = {} ;
    objectB = {} ;
	arrayA  = [1,3];
	stringA ="stringA";
}
});

test("should return a new object with same prototype as that of passed object", function() {
  	equals(YES, SC.beget(objectA) !== objectA, "Beget for an object") ;
	equals(YES, SC.beget(stringA) !== stringA, "Beget for a string") ;
	equals(YES, SC.beget(SC.hashFor(objectB))!==SC.hashFor(objectB), "Beget for a hash") ;
	equals(YES, SC.beget(arrayA) !== arrayA, "Beget for an array") ;
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/isArray.js"; 
}
(function() {
// ========================================================================
// SC.isArray Tests
// ========================================================================
/*globals module test */

var objectA,objectB,objectC, objectD, objectE; //global variables

module("Array Check" , {
	
	setup: function(){
		objectA = [1,2,3];
		objectB = 23;
		objectC = ["Hello","Hi"];
		objectD = "Hello";
		objectE	= {};
	}
});

test("should check if a given object is an array or not " ,function(){
	equals(SC.isArray(objectA),true);
	equals(SC.isArray(objectB),false);
	equals(SC.isArray(objectC),true);
	equals(SC.isArray(objectD),false);
	equals(SC.isArray(objectE),false);
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/tupleForPropertyPath.js"; 
}
(function() {
// ========================================================================
// SC.tupleForPropertyPath Tests
// ========================================================================
/*globals module test */

var object, object1,object3; //global variables

module("Checking the tuple for property path",{
	
	setup: function(){
		 object = SC.Object.create({
			name:'SproutCore',
			value:'',						//no value defined for the property
			objectA:SC.Object.create({
					propertyVal:"chainedProperty"
			})		
		 });
   }

});
   

test("should check for the tuple property", function() {
     var object2 = [];
     object2 = SC.tupleForPropertyPath(object.name,'');
     equals(object2[0], window, "the window object");
     equals(object2[1],'SproutCore',"the property name");	
     object2 = SC.tupleForPropertyPath(object.objectA.propertyVal,'object');
	 equals(object2[0],'object',"the root");
     equals(object2[1],'chainedProperty',"a chained property");
});

test("should check for the tuple property when path is undefined",function(){     //test case where no property defined
     var object2;
     object2 = SC.tupleForPropertyPath(object.value,'');
     equals(YES,object2 === null,'returns null for undefined path');	
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/IsEqual.js"; 
}
(function() {
// ========================================================================
// SC.isEqual Tests
// ========================================================================
/*globals module test */

var StringA, StringB, StringC;

module("String's - isEqual", {
	
	setup: function(){
	StringA = "Hello";
	StringB = "Hi";
	StringC = "Hello";
    }

});

test("strings should be equal ",function(){
	equals(SC.isEqual(StringA,StringB),false);
	equals(SC.isEqual(StringA,StringC),true);
});

var num1, num2, num3;

module("Number's - isEqual",{
 
     setup: function(){
	 num1 = 24;
	 num2 = 24;
	 num3 = 21;
     }

});
 
test("numericals should be equal ",function(){
    equals(SC.isEqual(num1,num2),true);
	equals(SC.isEqual(num1,num3),false);
}); 

var objectA,objectB, objectC; //global variables

module("Array's - isEqual",{
	
	setup: function(){
	objectA = [1,2];
	objectB = [1,2];
	objectC = [1];	
	}
	
});
	
test("array should be equal  ",function(){
	// NOTE: We don't test for array contents -- that would be too expensive.
	equals(SC.isEqual(objectA,objectB),false, 'two array instances with the same values should not be equal');
	equals(SC.isEqual(objectA,objectC),false, 'two array instances with different values should not be equal');
});	



	

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/itemType.js"; 
}
(function() {
var object;
module("item type", {
  setup: function() {
     object = SC.Object.create({
	
	    method:function(){
		
	    }
     });
	
  }   
  
});

test("should return the type for the passed item", function() {
	  var a = null;
	  var arr = [1,2,3];
	  var obj = {};
	  
      equals(SC.T_NULL,SC.typeOf(a),"item of type null ");
	  equals(SC.T_ARRAY,SC.typeOf(arr),"item of type array ");		  
	  equals(SC.T_HASH,SC.typeOf(obj),"item of type hash");
	  equals(SC.T_OBJECT,SC.typeOf(object),"item of type object");
	  equals(SC.T_FUNCTION,SC.typeOf(object.method),"item of type function") ;
	  equals(SC.T_CLASS,SC.typeOf(SC.Object),"item of type class");
});

var a,b;
module("none or undefined object type",{
	setup: function() {
		a = null;
		b = undefined; 
  }
});

test("should return true for null and undefined ",function(){
	equals(YES,SC.none(a),"for a null parameter passed  ");
	equals(YES,SC.none(b),"for a undefined parameter passed ");
});
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/objectForPropertyPath.js"; 
}
(function() {
// ========================================================================
// SC.objectForPropertyPath Tests
// ========================================================================
/*globals module test ok same equals expects */

// An ObjectController will make a content object or an array of content objects 
module("SC.objectForPropertyPath") ;

test("should be able to resolve an object on the window", function() {
  var myLocal = (window.myGlobal = { test: 'this '}) ;
  
  same(myLocal, { test: 'this '}) ;
  same(window.myGlobal, { test: 'this '}) ;
  
  // verify we can resolve our binding path
  same(SC.objectForPropertyPath('myGlobal'), { test: 'this '}) ;
  
  window.myGlobal =null ;
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/inspect.js"; 
}
(function() {
// ========================================================================
// SC.inspect Tests
// ========================================================================
/*globals module test ok isObj equals expects */

var obj1,obj2,obj3; //global variables

module("Inspect module",{
  
      setup: function(){	
        obj1 = [1,3,4,9];
        obj2 = 24;     
        obj3 = {};
     }
});


test("SC.inspect module should give a string type",function(){
    var object1 = SC.inspect(obj1); 	
	equals(YES,SC.T_STRING === SC.typeOf(object1) ,'description of the array');
	
	var object2 = SC.inspect(obj2);
	equals(YES,SC.T_STRING === SC.typeOf(object2),'description of the numbers');
	
	var object3 = SC.inspect(obj3);
	equals(YES,SC.T_STRING === SC.typeOf(object3),'description of the object');
});
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/guidFor.js"; 
}
(function() {
// ========================================================================
// SC.guidFor Tests
// ========================================================================
/*globals module test ok isObj equals expects */

var objectA, objectB ; // global variables

module("Object", {
  
  setup: function() {
    objectA = {} ;
    objectB = {} ;
  }
  
});

test("should return same guid for same instance every time", function() {
  equals(SC.guidFor(objectA), SC.guidFor(objectA)) ;
});

test("should return different guid for different instances", function() {
  ok(SC.guidFor(objectA) !==  SC.guidFor(objectB)) ;
});

test("guid should not parse to a number", function() {
  equals(YES, isNaN(parseInt(SC.guidFor(objectA), 0))) ;
});

var stringA, stringACopy, stringB ; // global variables

module("String", {
  
  setup: function() {
    stringA = "string A" ;
    stringACopy = "string A" ;
    stringB = "string B" ;
  }
  
});

test("same string instance should have same guide every time", function() {
  equals(SC.guidFor(stringA), SC.guidFor(stringA)) ;  
});

test("two string instances with same value should have same guid", function() {
  equals(SC.guidFor(stringA), SC.guidFor(stringACopy)) ;  
});

test("two instances with different value should have different guid", function() {
  ok(SC.guidFor(stringA) !==  SC.guidFor(stringB)) ;
});

test("guid should not parse to a number", function() {
  equals(YES, isNaN(parseInt(SC.guidFor(stringA), 0))) ;
});

var numberA, numberACopy, numberB ; // global variables

module("Number", {
  
  setup: function() {
    numberA = 23 ;
    numberACopy = 23 ;
    numberB = 34 ;
  }
  
});

test("same number instance should have same guide every time", function() {
  equals(SC.guidFor(numberA), SC.guidFor(numberA)) ;  
});

test("two number instances with same value should have same guid", function() {
  equals(SC.guidFor(numberA), SC.guidFor(numberACopy)) ;  
});

test("two instances with different value should have different guid", function() {
  ok(SC.guidFor(numberA) !==  SC.guidFor(numberB)) ;
});

test("guid should not parse to a number", function() {
  equals(YES, isNaN(parseInt(SC.guidFor(numberA), 0))) ;
});

module("Boolean") ;

test("should always have same guid", function() {
  equals(SC.guidFor(true), SC.guidFor(true)) ;
  equals(SC.guidFor(false), SC.guidFor(false)) ;
});

test("true should have different guid than false", function() {
  ok(SC.guidFor(true) !==  SC.guidFor(false)) ;
});

test("guid should not parse to a number", function() {
  equals(YES, isNaN(parseInt(SC.guidFor(true), 0)), 'guid for boolean-true') ;
  equals(YES, isNaN(parseInt(SC.guidFor(false), 0)), 'guid for boolean-false') ;
});

module("Null and Undefined") ;

test("should always have same guid", function() {
  equals(SC.guidFor(null), SC.guidFor(null)) ;
  equals(SC.guidFor(undefined), SC.guidFor(undefined)) ;
});

test("null should have different guid than undefined", function() {
  ok(SC.guidFor(null) !==  SC.guidFor(undefined)) ;
});

test("guid should not parse to a number", function() {
  equals(YES, isNaN(parseInt(SC.guidFor(null), 0))) ;
  equals(YES, isNaN(parseInt(SC.guidFor(undefined), 0))) ;
});

var array1, array1copy, array2, array2copy;

module("Arrays", {
	
	setup: function() {
	    array1 = ['a','b','c'] ;
	    array1copy = array1 ;
		array2 = ['1','2','3'];
	    array2copy = ['1','2','3'] ;
	}
}) ;

test("same array instance should have same guide every time", function(){
	equals(SC.guidFor(array1), SC.guidFor(array1));
	equals(SC.guidFor(array2), SC.guidFor(array2));
});

test("two array instances with same value, by assigning one to the other.", function() {
	equals(SC.guidFor(array1), SC.guidFor(array1copy)) ;
});

test("two array instances with same value, by assigning the same value", function() {
	ok(SC.guidFor(array2) !== SC.guidFor(array2copy)) ;
});

test("two instances with different value should have different guid", function() {
  ok(SC.guidFor(array1) !==  SC.guidFor(array2)) ;
  ok(SC.guidFor(array1copy) !==  SC.guidFor(array2copy)) ;
});

test("guid should not parse to a number", function() {
  equals(YES, isNaN(parseInt(SC.guidFor(array1), 0))) ;
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/compare.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Apple Inc. and contributors.
// License:   Licened under MIT license (see license.js)
// ==========================================================================
/*globals module ok equals same test MyApp */

// test parsing of query string
var v = [];
module("SC.compare()", {
  setup: function() {
    // setup dummy data
    v[0]  = null;
    v[1]  = false;
    v[2]  = true;
    v[3]  = -12;
    v[4]  = 3.5;
    v[5]  = 'a string';
    v[6]  = 'another string';
    v[7]  = 'last string';
    v[8]  = [1,2];
    v[9]  = [1,2,3];
    v[10] = [1,3];
    v[11] = {a: 'hash'};
    v[12] = SC.Object.create();
    v[13] = function (a) {return a;};
  }
});


// ..........................................................
// TESTS
// 

test("ordering should work", function() {
  for (var j=0; j < v.length; j++) {
    equals(SC.compare(v[j],v[j]), 0, j +' should equal itself');
    for (var i=j+1; i < v.length; i++) {
      equals(SC.compare(v[j],v[i]), -1, 'v[' + j + '] (' + SC.typeOf(v[j]) + ') should be smaller than v[' + i + '] (' + SC.typeOf(v[i]) + ')' );
    }
    
  }
}); 
  

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/core/makeArray.js"; 
}
(function() {
// ========================================================================
// SC.makeArray Tests
// ========================================================================
/*globals module test */

var objectA,objectB,objectC; //global variables

module("Make Array ", {
  setup: function() {
    var objectA = [1,2,3,4,5] ;  
	var objectC = SC.hashFor(objectA);
	var objectD = null;
	var stringA = "string A" ;		
  }
});

test("should return an array for the object passed ",function(){
	var arrayA  = ['value1','value2'] ;
	var numberA = 100;
	var stringA = "SproutCore" ;
	var obj = {} ;
	var ret = SC.makeArray(obj);
	equals(SC.isArray(ret),true);	
	ret = SC.makeArray(stringA);
	equals(SC.isArray(ret), true) ;  	
	ret = SC.makeArray(numberA);
	equals(SC.isArray(ret),true) ;  	
	ret = SC.makeArray(arrayA);
	equals(SC.isArray(ret),true) ;
});
})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/mixins/array.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore Costello - Property Observing Library
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

// Unit test some standard SC.Array implementations.

// ..........................................................
// BUILT-IN ARRAY
// 

SC.ArraySuite.generate("built-in Array");

// ..........................................................
// DUMMY ARRAY (BASIC FAKE IMPLEMENTATION)
// 

// Test the SproutCore Array interface on a custom object.
var DummyArray = SC.Object.extend(SC.Array, {
  
  length: 0,
  
  content: null,
  
  replace: function(idx, amt, objects) {
    if (!this.content) this.content = [] ;

    this.beginPropertyChanges() ;
    this.content.replace(idx,amt,objects) ;

    this.set('length', this.content.length) ;

    // figure out the range that changed.  If amt + objects are the same, use
    // amt.  Otherwise use total length.
    var len = objects ? objects.get('length') : 0;
    this.enumerableContentDidChange(idx, amt, len - amt) ;
    this.endPropertyChanges() ;
  },
  
  objectAt: function(idx) {
    if (!this.content) this.content = [] ;
    return this.content[idx] ;
  }
  
});

SC.ArraySuite.generate("DummyArray", {
  newObject: function(expected) {
    if (!expected || typeof expected === SC.T_NUMBER) {
      expected = this.expected(expected); 
    }
    return DummyArray.create({ content: expected, length: expected.length }) ;
  }
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/mixins/enumerable.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore Costello - Property Observing Library
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*globals module test ok isObj equals expects */

var enumerables ; // global variables

var DummyEnumerable = SC.Object.extend( SC.Enumerable, {
  
  content: [],
  
  length: function() { return this.content.length; }.property(),
  
  objectAt: function(idx) { return this.content[idx]; },
  
  nextObject: function(idx) { return this.content[idx]; },
  
  // add support for reduced properties.
  unknownProperty: function(key, value) {
    var ret = this.reducedProperty(key, value) ;
    if (ret === undefined) {
      if (value !== undefined) this[key] = value ;
      ret = value ;
    }
    return ret ;
  },
  
  pushObject: function(object) {
    this.content.push(object) ;
    this.enumerableContentDidChange() ;
  }
  
});

var runFunc = function(a,b) { return ['DONE', a, b]; } ;
var invokeWhileOK = function() { return "OK"; } ;
var invokeWhileNotOK = function() { return "FAIL"; };
var reduceTestFunc = function(prev, item, idx, e, pname) { return pname||'TEST'; } ;

var CommonArray = [
  {
    first: "Charles", 
    gender: "male", 
    californian: NO, 
    ready: YES, 
    visited: "Prague", 
    doneTravelling: NO, 
    run: runFunc,
    invokeWhileTest: invokeWhileOK,
    balance: 1
  },
  
  {
    first: "Jenna", 
    gender: "female", 
    californian: YES, 
    ready: YES, 
    visited: "Prague", 
    doneTravelling: NO, 
    run: runFunc,
    invokeWhileTest: invokeWhileOK,
    balance: 2 
  },
  
  {
    first: "Peter", 
    gender: "male", 
    californian: NO, 
    ready: YES, 
    visited: "Prague", 
    doneTravelling: NO, 
    run: runFunc,
    invokeWhileTest: invokeWhileNotOK,
    balance: 3 
  },
  
  {
    first: "Chris", 
    gender: "male", 
    californian: NO, 
    ready: YES, 
    visited: "Prague", 
    doneTravelling: NO, 
    run: runFunc,
    invokeWhileTest: invokeWhileOK,
    balance: 4
  }
];

module("Real Array & DummyEnumerable", {
  
  setup: function() { 
    enumerables = [SC.$A(CommonArray), DummyEnumerable.create({ content: CommonArray })] ;
  },
  
  teardown: function() {
    delete enumerables;
    delete Array.prototype["@max(balance)"] ; // remove cached value
    delete Array.prototype["@min(balance)"] ;
  }
  
});

test("should get enumerator that iterates through objects", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var e = src.enumerator() ;
    ok(e !== null, 'enumerator must not be null');
    
    var idx = 0;
    var cur ;
    while(cur = e.nextObject()) {
      equals(src.objectAt(idx), cur, "object at index %@".fmt(idx)) ;
      idx++;
    }
    
    equals(src.get('length'), idx) ;
  }
});

test("should return firstObject for item with content", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    equals(src.firstObject(), CommonArray[0], 'firstObject should return first object');
  }
  
  equals([].firstObject(), undefined, 'firstObject() on empty enumerable should return undefined');
});

test("should run forEach() to go through objects", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var idx = 0;
    
    // save for testing later
    var items = [] ;
    var indexes = [] ;
    var arrays = [] ;
    var targets = [] ;
    
    src.forEach(function(item, index, array) {
      items.push(item);
      indexes.push(index);
      arrays.push(array);
      targets.push(this);
    }, this);
    
    var len = src.get('length') ;
    for(idx=0;idx<len;idx++) {
      equals(items[idx], src.objectAt(idx)) ;
      equals(indexes[idx], idx) ;
      equals(arrays[idx], src) ;

      // use this method because equals() is taking too much time to log out
      // results.  probably an issue with jsDump
      ok(targets[idx] === this, 'target should always be this') ;
    }
  }
});

test("should map to values while passing proper params", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var idx = 0;
    
    // save for testing later
    var items = [] ;
    var indexes = [] ;
    var arrays = [] ;
    var targets = [] ;
    
    var mapped = src.map(function(item, index, array) {
      items.push(item);
      indexes.push(index);
      arrays.push(array);
      targets.push(this);
      
      return index ;
    }, this);
    
    var len = src.get('length') ;
    for(idx=0;idx<len;idx++) {
      equals(src.objectAt(idx), items[idx], "items") ;
      equals(idx, indexes[idx], "indexes") ;
      equals(src, arrays[idx], 'arrays') ;
      equals(SC.guidFor(this), SC.guidFor(targets[idx]), "this") ;
      
      equals(idx, mapped[idx], "mapped") ;
    }
  }
});

test("should filter to items that return for callback", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var idx = 0;
    
    // save for testing later
    var items = [] ;
    var indexes = [] ;
    var arrays = [] ;
    var targets = [] ;
    
    var filtered = src.filter(function(item, index, array) {
      items.push(item);
      indexes.push(index);
      arrays.push(array);
      targets.push(this);
      
      return item.gender === "female" ;
    }, this);
    
    var len = src.get('length') ;
    for(idx=0;idx<len;idx++) {
      equals(src.objectAt(idx), items[idx], "items") ;
      equals(idx, indexes[idx], "indexes") ;
      equals(src, arrays[idx], 'arrays') ;
      equals(SC.guidFor(this), SC.guidFor(targets[idx]), "this") ;
    }
    
    equals(filtered.length, 1) ;
    equals(filtered[0].first, "Jenna") ;
  }
});

test("should return true if function for every() returns true", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var idx = 0 ;
    
    // save for testing later
    var items = [] ;
    var indexes = [] ;
    var arrays = [] ;
    var targets = [] ;
    
    var result = src.every(function(item, index, array) {
      items.push(item) ;
      indexes.push(index) ;
      arrays.push(array) ;
      targets.push(this) ;
      
      return true ;
    }, this);
    
    var len = src.get('length') ;
    for(idx=0;idx<len;idx++) {
      equals(src.objectAt(idx), items[idx], "items") ;
      equals(idx, indexes[idx], "indexes") ;
      equals(src, arrays[idx], 'arrays') ;
      equals(SC.guidFor(this), SC.guidFor(targets[idx]), "this") ;
    }
    
    equals(result, YES) ;
  }
});

test("should return false if one function for every() returns false", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var result = src.every(function(item, index, array) {
      return item.gender === "male" ;
    }, this);
    equals(result, NO) ;
  }
});

test("should return false if all functions for some() returns false", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var idx = 0 ;
    
    // save for testing later
    var items = [] ;
    var indexes = [] ;
    var arrays = [] ;
    var targets = [] ;
    
    var result = src.some(function(item, index, array) {
      items.push(item) ;
      indexes.push(index) ;
      arrays.push(array) ;
      targets.push(this) ;
      
      return false ;
    }, this);
    
    var len = src.get('length') ;
    for(idx=0;idx<len;idx++) {
      equals(src.objectAt(idx), items[idx], "items") ;
      equals(idx, indexes[idx], "indexes") ;
      equals(src, arrays[idx], 'arrays') ;
      equals(SC.guidFor(this), SC.guidFor(targets[idx]), "this") ;
    }
    
    equals(result, NO) ;
  }
});

test("should return true if one function for some() returns true", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var result = src.some(function(item, index, array) {
      return item.gender !== "male" ;
    }, this);
    equals(result, YES) ;
  }
});

test("should mapProperty for all items", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var mapped = src.mapProperty("first") ;
    var idx ;
    var len = src.get('length') ;
    for(idx=0;idx<len;idx++) {
      equals(mapped[idx], src.objectAt(idx).first) ;
    }
  }
});

test("should filterProperty with match", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var filtered = src.filterProperty("gender", "female") ;
    equals(filtered.length, 1) ;
    equals(filtered[0].first, "Jenna") ;
  }
});

test("should filterProperty with default bool", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var filtered = src.filterProperty("californian") ;
    equals(filtered.length, 1) ;
    equals(filtered[0].first, "Jenna") ;
  }
});

test("everyProperty should return true if all properties macth", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var ret = src.everyProperty('visited', 'Prague') ;
    equals(YES, ret, "visited") ;
  }
});

test("everyProperty should return true if all properties true", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var ret = src.everyProperty('ready') ;
    equals(YES, ret, "ready") ;
  }
});

test("everyProperty should return false if any properties false", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var ret = src.everyProperty('gender', 'male') ;
    equals(NO, ret, "ready") ;
  }
});

test("someProperty should return false if all properties not match", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var ret = src.someProperty('visited', 'Timbuktu') ;
    equals(NO, ret, "visited") ;
  }
});

test("someProperty should return false if all properties false", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var ret = src.someProperty('doneTravelling') ;
    equals(NO, ret, "doneTravelling") ;
  }
});

test("someProperty should return true if any properties true", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var ret = src.someProperty('first', 'Charles') ;
    equals(YES, ret, "first") ;
  }
});

test("invokeWhile should call method on member objects until return does not match", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    var ret = src.invokeWhile("OK", "invokeWhileTest", "item2") ;
    equals("FAIL", ret, "return value");
  }
});

test("get @min(balance) should return the minimum balance", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    equals(1, src.get('@min(balance)')) ;
  }
});

test("get @max(balance) should return the maximum balance", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    equals(4, src.get('@max(balance)')) ;
  }
});

test("get @minObject(balance) should return the record with min balance", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    equals(src.objectAt(0), src.get('@minObject(balance)')) ;
  }
});

test("get @maxObject(balance) should return the record with the max balance", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    equals(src.objectAt(3), src.get('@maxObject(balance)')) ;
  }
});

test("get @sum(balance) should return the sum of the balances.", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    equals(1+2+3+4, src.get("@sum(balance)")) ;
  }
});

test("get @average(balance) should return the average of balances", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    equals((1+2+3+4)/4, src.get("@average(balance)")) ;
  }
});

test("should invoke custom reducer", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    // install reducer method
    src.reduceTest = reduceTestFunc ;
    equals("TEST", src.get("@test")) ;
    equals("prop", src.get("@test(prop)")) ;
  }
});

test("should trigger observer of reduced prop when array changes once property retrieved once", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    // get the property...this will install the reducer property...
    src.get("@max(balance)") ;
    
    // install observer
    var observedValue = null ;
    src.addObserver("@max(balance)", function() { 
      observedValue = src.get("@max(balance)");
    }) ;
    
    src.addProbe('[]') ;
    src.addProbe('@max(balance)');
    
    // add record to array
    src.pushObject({ 
      first: "John", 
      gender: "male", 
      californian: NO, 
      ready: YES, 
      visited: "Paris", 
      balance: 5
    }) ;
    
    //SC.NotificationQueue.flush() ; // force observers to trigger
    
    // observed value should now be set because the reduced property observer
    // was triggered when we changed the array contents.
    equals(5, observedValue, "observedValue") ;
  }
});

test("should trigger observer of reduced prop when array changes - even if you never retrieved the property before", function() {
  var src, ary2 = enumerables ;
  for (var idx2=0, len2=ary2.length; idx2<len2; idx2++) {
    src = ary2[idx2] ;
    // install observer
    var observedValue = null ;
    src.addObserver("@max(balance)", function() { 
      observedValue = src.get("@max(balance)");
    }) ;
    
    // add record to array
    src.pushObject({ 
      first: "John", 
      gender: "male", 
      californian: NO, 
      ready: YES, 
      visited: "Paris", 
      balance: 5
    }) ;
    
    //SC.NotificationQueue.flush() ; // force observers to trigger
    
    // observed value should now be set because the reduced property observer
    // was triggered when we changed the array contents.
    equals(5, observedValue, "observedValue") ;
  }
});

test("should find the first element matching the criteria", function() {
  var people = enumerables[1] ;
  var jenna = people.find(function(person) { return person.gender == 'female'; });
  equals(jenna.first, 'Jenna');
});

var source ; // global variables

module("Real Array", {
  
  setup: function() { 
    source = SC.$A(CommonArray); 
  },
  
  teardown: function() { 
    delete source ; 
    
    delete Array.prototype["@max(balance)"] ; // remove cached value
    delete Array.prototype["@min(balance)"] ;
  }

});

/*
  This is a particular problem because reduced properties are registered
  as dependent keys, which are not automatically configured in native 
  Arrays (where the SC.Object.init method is not run).  

  The fix for this problem was to add an initObservable() method to 
  SC.Observable that will configure bindings and dependent keys.  This
  method is called from SC.Object.init() and it is called in
  SC.Observable._notifyPropertyChanges if it has not been called already.

  SC.Enumerable was in turn modified to register reducers as dependent 
  keys so that now they will be registered on the Array before any 
  property change notifications are sent.
*/
test("should notify observers even if reduced property is cached on prototype", function() {
  // make sure reduced property is cached
  source.get("@max(balance)") ;
  
  // now make a clone and observe
  source = SC.$A(CommonArray) ;
  
  // get the property...this will install the reducer property...
  source.get("@max(balance)") ;
  
  // install observer
  var observedValue = null ;
  source.addObserver("@max(balance)", function() { 
    observedValue = source.get("@max(balance)");
  }) ;
  
  source.addProbe('[]') ;
  source.addProbe('@max(balance)');
  
  // add record to array
  source.pushObject({ 
    first: "John", 
    gender: "male", 
    californian: NO, 
    ready: YES, 
    visited: "Paris", 
    balance: 5
  }) ;
  
  //SC.NotificationQueue.flush() ; // force observers to trigger
  
  // observed value should now be set because the reduced property observer
  // was triggered when we changed the array contents.
  equals(5, observedValue, "observedValue") ;
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/mixins/propertyChanges.js"; 
}
(function() {
var ObjectA;
module("object.propertyChanges()", {	
	setup: function() {
		ObjectA = SC.Object.create({
			normal: 'value',
			normal1: 'zeroValue',
						
			action: function() {
				this.normal1= 'newValue';
			}.observes('normal'),
			
			normal2: 'dependentValue',
			normal3: 'notifiedValue',
			
			notifyAction: function() {
				this.normal3= 'newDependentValue';
			}.observes('normal2'),
			
			notifyAllAction: function() {
				this.normal2= 'newZeroValue';
			}.observes('normal1')			
		});
  }
});

// CAJ: These tests are OK but the purpose of begin/end property changes is
// to suspend notifications.  you should do something like:
/*
  obj.beginPropertyChanges()
  obj.set('foo', 'bar');
  -- verify that observer for 'foo' did not fire
  obj.endPropertyChanges()
  -- verify that observer for 'foo' did fire
*/
// also, we need some tests verifying that begin/end property changes can
// be nested.  When they are nested, observers should not fire until you 
// unnest them.  i.e.  
/*
  obj.beginPropertyChanges()
    obj.beginPropertyChanges() // nested!
      obj.set('foo', 'bar')
    obj.endPropertyChanges(); // nested - do not fire.
  obj.endProeprtyChanges()
  -- observers fire here!
*/
//
test("should increment the indicator before begining the changes to the object", function() {
    equals(ObjectA.beginPropertyChanges()._kvo_changeLevel, 1) ;
});

test("should increment the indicator before begining the changes to the object", function() {
    equals(ObjectA.endPropertyChanges()._kvo_changeLevel, 0) ;
});

// CAJ: This test works but its confusing.  the relationship between 'normal' 
// and 'normal1' is really unclear.  Rename these properties
// to something more descriptive and add comments to this test explaining 
// what you expect to have happen.  You should always comment in the test 
// anytime you expect something to happen in the background (such as expecting
// an observer to fire.) 
test("should indicate that the property of an object has just changed", function() {
	equals(ObjectA.propertyWillChange('normal'),ObjectA) ;
	ObjectA.normal = 'newValue';
	equals(ObjectA.propertyDidChange('normal', null),ObjectA) ;
	equals(ObjectA.normal1,'newValue') ;
});

// CAJ:  See my comment from above.  It's not clear how this test works.  
// Consider using different property names and add a comment inline to 
// explain that you expect an observer to fire.
test("should notify that the property of an object has changed", function() {
	ObjectA.notifyPropertyChange('normal2','value');
	equals(ObjectA.normal3,'newDependentValue') ;
});

// CAJ:  Same comment here as the previous two tests.
test("should notify all observers that their property might have changed", function() {
	ObjectA.allPropertiesDidChange();
	equals(ObjectA.normal2,'newZeroValue') ;
});


})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/mixins/comparable.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore Costello - Property Observing Library
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            Portions ©2008-2009 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*globals module test ok isObj equals expects */

var Rectangle = SC.Object.extend({
  length: 0,
  width: 0,
  
  area: function() {
    return this.get('length') * this.get('width');
  }
});

Rectangle.mixin(SC.Comparable, {
  compare: function(a, b) {
    return SC.compare(a.area(), b.area());
  }
});

var r1, r2;

module("Comparable", {
  
  setup: function() {
    r1 = Rectangle.create({length: 6, width: 12});
    r2 = Rectangle.create({length: 6, width: 13});
  },
  
  teardown: function() {
  }
  
});

test("should be comparable and return the correct result", function() {
  equals(r1.constructor.isComparable, YES);
  equals(SC.compare(r1, r1), 0);
  equals(SC.compare(r1, r2), -1);
  equals(SC.compare(r2, r1), 1);
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/mixins/observable/observable.js"; 
}
(function() {
// ========================================================================
// SC.Observable Tests
// ========================================================================
/*globals module test ok isObj equals expects Namespace */

var object, ObjectC, ObjectD, objectA, objectB ;

// ..........................................................
// GET()
// 

module("object.get()", {
  
  setup: function() {
    object = SC.Object.create({
      
      normal: 'value',
      numberVal: 24,
      toggleVal: true,

      computed: function() { return 'value'; }.property(),
      
      method: function() { return "value"; },
      
      nullProperty: null,
      
      unknownProperty: function(key, value) {
        this.lastUnknownProperty = key ;
        return "unknown" ;
      }
      
    });
  }
  
});

test("should get normal properties", function() {
  equals(object.get('normal'), 'value') ;
});

test("should call computed properties and return their result", function() {
  equals(object.get("computed"), "value") ;
});

test("should return the function for a non-computed property", function() {
  var value = object.get("method") ;
  equals(SC.typeOf(value), SC.T_FUNCTION) ;
});

test("should return null when property value is null", function() {
  equals(object.get("nullProperty"), null) ;
});

test("should call unknownProperty when value is undefined", function() {
  equals(object.get("unknown"), "unknown") ;
  equals(object.lastUnknownProperty, "unknown") ;
});


// ..........................................................
// SET()
// 

module("object.set()", {
  
  setup: function() {
    object = SC.Object.create({
      
      // normal property
      normal: 'value',
      
      // computed property
      _computed: "computed",
      computed: function(key, value) {
        if (value !== undefined) {
          this._computed = value ;
        }
        return this._computed ;
      }.property(),
      
      // method, but not a property
      _method: "method",
      method: function(key, value) {
        if (value !== undefined) {
          this._method = value ;
        }
        return this._method ;
      },
      
      // null property
      nullProperty: null,
      
      // unknown property
      _unknown: 'unknown',
      unknownProperty: function(key, value) {
        if (value !== undefined) {
          this._unknown = value ;
        }
        return this._unknown ;
      }
      
    });
  }

});

test("should change normal properties and return this", function() {
  var ret = object.set("normal", "changed") ;
  equals(object.normal, "changed") ;
  equals(ret, object) ;
});

test("should call computed properties passing value and return this", function() {
  var ret = object.set("computed", "changed") ;
  equals(object._computed, "changed") ;
  equals(SC.typeOf(object.computed), SC.T_FUNCTION) ;
  equals(ret, object) ;
});

test("should replace the function for a non-computed property and return this", function() {
  var ret = object.set("method", "changed") ;
  equals(object._method, "method") ; // make sure this was NOT run
  ok(SC.typeOf(object.method) !== SC.T_FUNCTION) ;
  equals(ret, object) ;
});

test("should replace prover when property value is null", function() {
  var ret = object.set("nullProperty", "changed") ;
  equals(object.nullProperty, "changed") ;
  equals(object._unknown, "unknown"); // verify unknownProperty not called.
  equals(ret, object) ;
});

test("should call unknownProperty with value when property is undefined", function() {
  var ret = object.set("unknown", "changed") ;
  equals(object._unknown, "changed") ;
  equals(ret, object) ;
});

// ..........................................................
// COMPUTED PROPERTIES
// 

module("Computed properties", {
  setup: function() {
    object = SC.Object.create({
      
      // REGULAR
      
      computedCalls: [],
      computed: function(key, value) {
        this.computedCalls.push(value);
        return 'computed';
      }.property(),
      
      computedCachedCalls: [],
      computedCached: function(key, value) {
        this.computedCachedCalls.push(value);
        return 'computedCached';
      }.property().cacheable(),
      
      
      // DEPENDENT KEYS
      
      changer: 'foo',
      
      dependentCalls: [],
      dependent: function(key, value) {
        this.dependentCalls.push(value);
        return 'dependent';
      }.property('changer'),
      
      dependentCachedCalls: [],
      dependentCached: function(key, value) {
        this.dependentCachedCalls.push(value);
        return 'dependentCached';
      }.property('changer').cacheable(),
      
      // everytime it is recomputed, increments call
      incCallCount: 0,
      inc: function() {
        return this.incCallCount++;
      }.property('changer').cacheable(),

      // depends on cached property which depends on another property...
      nestedIncCallCount: 0,
      nestedInc: function(key, value) {
        return this.nestedIncCallCount++;
      }.property('inc').cacheable(),
      
      // two computed properties that depend on a third property
      state: 'on',
      isOn: function(key, value) {
        if (value !== undefined) this.set('state', 'on');
        return this.get('state') === 'on';
      }.property('state'),
      
      isOff: function(key, value) {
        if (value !== undefined) this.set('state', 'off');
        return this.get('state') === 'off';
      }.property('state')
      
    }) ;
  }
});

test("getting values should call function return value", function() {
  
  // get each property twice. Verify return.
  var keys = 'computed computedCached dependent dependentCached'.w();
  
  keys.forEach(function(key) {
    equals(object.get(key), key, 'Try #1: object.get(%@) should run function'.fmt(key));
    equals(object.get(key), key, 'Try #2: object.get(%@) should run function'.fmt(key));
  });
  
  // verify each call count.  cached should only be called once
  'computedCalls dependentCalls'.w().forEach(function(key) {
    equals(object[key].length, 2, 'non-cached property %@ should be called 2x'.fmt(key));
  });

  'computedCachedCalls dependentCachedCalls'.w().forEach(function(key) {
    equals(object[key].length, 1, 'non-cached property %@ should be called 1x'.fmt(key));
  });
  
});

test("setting values should call function return value", function() {
  
  // get each property twice. Verify return.
  var keys = 'computed dependent computedCached dependentCached'.w();
  var values = 'value1 value2'.w();
  
  keys.forEach(function(key) {
    
    equals(object.set(key, values[0]), object, 'Try #1: object.set(%@, %@) should run function'.fmt(key, values[0]));

    equals(object.set(key, values[1]), object, 'Try #2: object.set(%@, %@) should run function'.fmt(key, values[1]));
    equals(object.set(key, values[1]), object, 'Try #3: object.set(%@, %@) should not run function since it is setting same value as before'.fmt(key, values[1]));
    
  });
  
  
  // verify each call count.  cached should only be called once
  keys.forEach(function(key) {
    var calls = object[key + 'Calls'], idx;
    equals(calls.length, 2, 'set(%@) should be called 2x'.fmt(key));
    for(idx=0;idx<2;idx++) {
      equals(calls[idx], values[idx], 'call #%@ to set(%@) should have passed value %@'.fmt(idx+1, key, values[idx]));
    }
  });
  
});

test("notify change should clear cache", function() {

  // call get several times to collect call count
  object.get('computedCached'); // should run func
  object.get('computedCached'); // should not run func

  object.propertyWillChange('computedCached')
    .propertyDidChange('computedCached');
    
  object.get('computedCached'); // should run again
  equals(object.computedCachedCalls.length, 2, 'should have invoked method 2x');
});

test("change dependent should clear cache", function() {

  // call get several times to collect call count
  var ret1 = object.get('inc'); // should run func
  equals(object.get('inc'), ret1, 'multiple calls should not run cached prop');

  object.set('changer', 'bar');
    
  equals(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again
});

test("just notifying change of dependent should clear cache", function() {

  // call get several times to collect call count
  var ret1 = object.get('inc'); // should run func
  equals(object.get('inc'), ret1, 'multiple calls should not run cached prop');

  object.notifyPropertyChange('changer');
    
  equals(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again
});

test("changing dependent should clear nested cache", function() {

  // call get several times to collect call count
  var ret1 = object.get('nestedInc'); // should run func
  equals(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');

  object.set('changer', 'bar');
    
  equals(object.get('nestedInc'), ret1+1, 'should increment after dependent key changes'); // should run again
  
});

test("just notifying change of dependent should clear nested cache", function() {

  // call get several times to collect call count
  var ret1 = object.get('nestedInc'); // should run func
  equals(object.get('nestedInc'), ret1, 'multiple calls should not run cached prop');

  object.notifyPropertyChange('changer');
    
  equals(object.get('nestedInc'), ret1+1, 'should increment after dependent key changes'); // should run again
  
});


// This verifies a specific bug encountered where observers for computed 
// properties would fire before their prop caches were cleared.
test("change dependent should clear cache when observers of dependent are called", function() {

  // call get several times to collect call count
  var ret1 = object.get('inc'); // should run func
  equals(object.get('inc'), ret1, 'multiple calls should not run cached prop');

  // add observer to verify change...
  object.addObserver('inc', this, function() {
    equals(object.get('inc'), ret1+1, 'should increment after dependent key changes'); // should run again
  });

  // now run
  object.set('changer', 'bar');
    
});

test("allPropertiesDidChange should clear cache", function() {
  // note: test this with a computed method that returns a different value
  // each time to ensure clean function.
  var ret1 = object.get('inc');
  equals(object.get('inc'), ret1, 'should not change after first call');
  
  // flush all props
  object.allPropertiesDidChange();
  equals(object.get('inc'), ret1+1, 'should increment after change');
});

test('setting one of two computed properties that depend on a third property should clear the kvo cache', function() {
  // we have to call set twice to fill up the cache
  object.set('isOff', YES);
  object.set('isOn', YES);
  
  // setting isOff to YES should clear the kvo cache
  object.set('isOff', YES);
  equals(object.get('isOff'), YES, 'object.isOff should be YES');
  equals(object.get('isOn'), NO, 'object.isOn should be NO');
});

// ..........................................................
// OBSERVABLE OBJECTS
// 

module("Observable objects & object properties ", {
  
  setup: function() {
    object = SC.Object.create({
      
      normal: 'value',
      abnormal: 'zeroValue',
      numberVal: 24,
      toggleVal: true,
      observedProperty: 'beingWatched',
      testRemove: 'observerToBeRemoved',  
      normalArray: [1,2,3,4,5],
    
      automaticallyNotifiesObserversFor : function(key) { 
        return NO;    
      },  
    
      getEach: function() {
        var keys = ['normal','abnormal'];
        var ret = [];
        for(var idx=0; idx<keys.length;idx++) {
          ret[ret.length] = this.getPath(keys[idx]);
        }
        return ret ;
      },
    
      newObserver:function(){
        this.abnormal = 'changedValueObserved';
      },
    
      testObserver:function(){
        this.abnormal = 'removedObserver';
      }.observes('normal'),
    
      testArrayObserver:function(){
        this.abnormal = 'notifiedObserver';
      }.observes('*normalArray.[]')
    
    });
  }   
  
});

test('incrementProperty and decrementProperty',function(){
  var newValue = object.incrementProperty('numberVal');
  equals(25,newValue,'numerical value incremented');
  object.numberVal = 24;
  newValue = object.decrementProperty('numberVal');
  equals(23,newValue,'numerical value decremented');
});

test('toggle function, should be boolean',function(){
  equals(object.toggleProperty('toggleVal',true,false),object.get('toggleVal')); 
  equals(object.toggleProperty('toggleVal',true,false),object.get('toggleVal'));
  equals(object.toggleProperty('toggleVal',undefined,undefined),object.get('toggleVal'));
});

test('should not notify the observers of a property automatically',function(){
  object.set('normal', 'doNotNotifyObserver'); 
  equals(object.abnormal,'zeroValue')  ;
});

test('should notify array observer when array changes',function(){
  object.normalArray.replace(0,0,6);
  equals(object.abnormal, 'notifiedObserver', 'observer should be notified');
});


module("object.addObserver()", {  
  setup: function() {
        
    ObjectC = SC.Object.create({
      
      ObjectE:SC.Object.create({
        propertyVal:"chainedProperty"
      }),
      
      normal: 'value',
      normal1: 'zeroValue',
      normal2: 'dependentValue',
      incrementor: 10,
      
      action: function() {
        this.normal1= 'newZeroValue';
      },
            
      observeOnceAction: function() {
        this.incrementor= this.incrementor+1;
      },
              
      chainedObserver:function(){
        this.normal2 = 'chainedPropertyObserved' ;
      }
      
    });
  }
});

test("should register an observer for a property", function() {
  ObjectC.addObserver('normal', ObjectC, 'action');
  ObjectC.set('normal','newValue');
  equals(ObjectC.normal1, 'newZeroValue');
});

test("should register an observer for a property - Special case of chained property", function() {
  ObjectC.addObserver('ObjectE.propertyVal',ObjectC,'chainedObserver');
  ObjectC.ObjectE.set('propertyVal',"chainedPropertyValue");
  equals('chainedPropertyObserved',ObjectC.normal2);
  ObjectC.normal2 = 'dependentValue';
  ObjectC.set('ObjectE','');
  equals('chainedPropertyObserved',ObjectC.normal2);  
});


module("object.removeObserver()", {  
  setup: function() {
    ObjectD = SC.Object.create({
      
      ObjectF:SC.Object.create({
        propertyVal:"chainedProperty"
      }),
      
      normal: 'value',
      normal1: 'zeroValue',
      normal2: 'dependentValue',
      ArrayKeys: ['normal','normal1'],
      
      addAction: function() {
        this.normal1 = 'newZeroValue';
      },
      removeAction: function() {
        this.normal2 = 'newDependentValue';
      },
      removeChainedObserver:function(){
        this.normal2 = 'chainedPropertyObserved' ;
      }
    });
    
  }
});

test("should unregister an observer for a property", function() {
  ObjectD.addObserver('normal', ObjectD, 'addAction');
  ObjectD.set('normal','newValue');
  equals(ObjectD.normal1, 'newZeroValue');
  
  ObjectD.set('normal1','zeroValue');
  
  ObjectD.removeObserver('normal', ObjectD, 'addAction');
  ObjectD.set('normal','newValue');
  equals(ObjectD.normal1, 'zeroValue');  
});


test("should unregister an observer for a property - special case when key has a '.' in it.", function() {
  ObjectD.addObserver('ObjectF.propertyVal',ObjectD,'removeChainedObserver');
  ObjectD.ObjectF.set('propertyVal',"chainedPropertyValue");
  ObjectD.removeObserver('ObjectF.propertyVal',ObjectD,'removeChainedObserver');
  ObjectD.normal2 = 'dependentValue';
  ObjectD.ObjectF.set('propertyVal',"removedPropertyValue");
  equals('dependentValue',ObjectD.normal2);
  ObjectD.set('ObjectF','');
  equals('dependentValue',ObjectD.normal2);  
});



module("Bind function ", {
  
  setup: function() {
    objectA = SC.Object.create({
      name: "Sproutcore",
      location: "Timbaktu"
    });

    objectB = SC.Object.create({
      normal: "value",
      computed:function() {
        this.normal = 'newValue';
      }
    }) ;
         
    Namespace = {
      objectA: objectA,
      objectB: objectB  
    } ;
  }
});

test("should bind property with method parameter as undefined", function() {
  // creating binding
  objectA.bind("name", "Namespace.objectB.normal",undefined) ;
  SC.Binding.flushPendingChanges() ; // actually sets up up the binding
  
  // now make a change to see if the binding triggers.
  objectB.set("normal", "changedValue") ;
  
  // support new-style bindings if available
  SC.Binding.flushPendingChanges();
  equals("changedValue", objectA.get("name"), "objectA.name is binded");
});

// ..........................................................
// SPECIAL CASES
// 

test("changing chained observer object to null should not raise exception", function() {

  var obj = SC.Object.create({
    foo: SC.Object.create({
      bar: SC.Object.create({ bat: "BAT" })
    })
  });
  
  var callCount = 0;
  obj.foo.addObserver('bar.bat', obj, function(target, key, value) { 
    equals(target, null, 'new target value should be null');
    equals(key, 'bat', 'key should be bat');
    callCount++; 
  });
  
  SC.run(function() {
    obj.foo.set('bar', null);
  });

  //debugger ;
  equals(callCount, 1, 'changing bar should trigger observer');
  expect(3);
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/mixins/observable/registerDependentKeys.js"; 
}
(function() {
// ==========================================================================
// Project:   SproutCore - JavaScript Application Framework
// Copyright: ©2006-2009 Sprout Systems, Inc. and contributors.
//            portions copyright @2009 Apple Inc.
// License:   Licened under MIT license (see license.js)
// ==========================================================================

/*globals module test ok equals same */

var object ;

module("object.registerDependentKeys()", {  
  setup: function() {
    object = SC.Object.create({

        // normal properties
        firstName:  'John',
        lastName:   'Doe',
        observedValue: '',

        // computed property
        fullName: function() {
          return this.getEach('firstName','lastName').compact().join(' ');
        }.property(),

        // init to setup registerDependentKey...
        init: function() {
          arguments.callee.base.apply(this,arguments);
          this.registerDependentKey('fullName', 'firstName', 'lastName');
        },

        //observer that should fire whenever the 'fullName' property changes
        fullNameDidChange:  function() {
          this.set('observedValue', this.get('fullName')) ;
        }.observes('fullName')
    });
  }
});


test("should indicate the registered property changes if the dependent key value changes", function() {
  // now, change the firstName...
  object.set('firstName', 'Jane');

  // since fullName is 'dependent' on firstName, then the observer for  
  // 'fullName' should fire here because you changed a dependent key.
  equals(object.get('observedValue'), 'Jane Doe');

  // now change the lastName
  object.set('lastName', 'Johnson');

  // again, fullName is 'dependent' on lastName, so observer for  
  // fullName should fire.
  equals(object.get('observedValue'), 'Jane Johnson');
});


test("should indicate the registered property changes if the dependent key value changes and change is within begin property loop ", function() {
  // Wrap the changes with begin property changes call
  object.beginPropertyChanges();
  
  // now, change the firstName & lastname...
  object.set('firstName', 'Jane');
  object.set('lastName', 'Johnson');
  
  // The observer for fullName should not have fired yet at this  
  // point because we are inside a propertyChange loop.
  equals(object.get('observedValue'), '');
  
  //End the property changes loop.
  object.endPropertyChanges();
  
  // now change the lastName
  object.set('lastName', 'Johnson');

  // again, fullName is 'dependent' on lastName, so observer for  
  // fullName should fire.
  equals(object.get('observedValue'), 'Jane Johnson');
});

})();
</script>
<script type="text/javascript">
if (typeof SC !== "undefined") {
  SC.mode = "TEST_MODE";
  SC.filename = "static/sproutcore/runtime/en/current/tests/mixins/observable/propertyChanges.js"; 
}
(function() {
// ========================================================================
// SC.Observable Tests
// ========================================================================
/*globals module test ok isObj equals expects */

var revMatches = NO , ObjectA;

module("object.propertyChanges", {  
  setup: function() {
    ObjectA = SC.Object.create({
      foo  : 'fooValue',
      prop : 'propValue',
            
      action: function() {
        this.prop= 'changedPropValue';
      }.observes('foo'),
      
      newFoo : 'newFooValue',
      newProp: 'newPropValue',
      
      notifyAction: function() {
        this.newProp = 'changedNewPropValue';
      }.observes('newFoo'),
      
      notifyAllAction: function() {
        this.newFoo = 'changedNewFooValue';
      }.observes('prop'),

      starProp: null,
      starObserver: function(target, key, value, rev) {
        revMatches = (rev === target.propertyRevision) ;
        this.starProp = key;
      }
      
    });
    }
});


test("should observe the changes within the nested begin / end property changes", function() {
    
  //start the outer nest
  ObjectA.beginPropertyChanges();
    // Inner nest
    ObjectA.beginPropertyChanges();
        ObjectA.set('foo', 'changeFooValue');
      equals(ObjectA.prop, "propValue") ;
      ObjectA.endPropertyChanges();
    
    //end inner nest
    ObjectA.set('prop', 'changePropValue');
    equals(ObjectA.newFoo, "newFooValue") ;
  //close the outer nest
  ObjectA.endPropertyChanges();
  
  equals(ObjectA.prop, "changedPropValue") ;
  equals(ObjectA.newFoo, "changedNewFooValue") ;
  
});

test("should increment the indicator before begining the changes to the object", function() {
    equals(ObjectA.beginPropertyChanges()._kvo_changeLevel, 1) ;
});

test("should increment the indicator before begining the changes to the object", function() {
    equals(ObjectA.endPropertyChanges()._kvo_changeLevel, 0) ;
});

test("should observe the changes within the begin and end property changes", function() {
    
  ObjectA.beginPropertyChanges();
    ObjectA.set('foo', 'changeFooValue');
    
  equals(ObjectA.prop, "propValue") ;
    ObjectA.endPropertyChanges();
    
  equals(ObjectA.prop, "changedPropValue") ;
});

test("should indicate that the property of an object has just changed", function() {
  // inidicate that proprty of foo will change to its subscribers
  ObjectA.propertyWillChange('foo') ;
  
  //Value of the prop is unchanged yet as this will be changed when foo changes
  equals(ObjectA.prop, 'propValue' ) ;
  
  //change the value of foo.
  ObjectA.foo = 'changeFooValue';
  
  // Indicate the subscribers of foo that the value has just changed
  ObjectA.propertyDidChange('foo', null) ;
  
  // Values of prop has just changed
  equals(ObjectA.prop,'changedPropValue') ;
});

test("should notify that the property of an object has changed", function() {
  // Notify to its subscriber that the values of 'newFoo' will be changed. In this
  // case the observer is "newProp". Therefore this will call the notifyAction function
  // and value of "newProp" will be changed.
  ObjectA.notifyPropertyChange('newFoo','fooValue');
  
  //value of newProp changed.
  equals(ObjectA.newProp,'changedNewPropValue') ;
});

test("should notify all observers that their property might have changed", function() {
  //When this function is called, all the subscribers are notified that something has
  //Changed. So when allPropertiesDidChange() is called, all the subscribers get invoked. 
  ObjectA.allPropertiesDidChange();
  
  //All the values changed.
  equals(ObjectA.prop,'changedPropValue') ;
  equals(ObjectA.newProp,'changedNewPropValue') ;
  equals(ObjectA.newFoo,'changedNewFooValue') ;
});

test("star observers", function() {
  // setup observer
  ObjectA.addObserver('*', ObjectA, ObjectA.starObserver);
  ObjectA.set('foo', 'bar');
  equals(ObjectA.starProp, 'foo', 'should have fired star observer for foo');
  
  ObjectA.set('bar', 'foo');
  equals(ObjectA.starProp, 'bar', 'should have fired star observer for bar');
});

test("revision passed to observers should match .propertyRevision", function() {
    
  equals(revMatches, true) ;
  
});

})();
</script>
	</body>
</html>
